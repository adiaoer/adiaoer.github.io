<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[比STL还STL的pbds]]></title>
    <url>%2F2020%2F01%2F31%2Fpbds%2F</url>
    <content type="text"><![CDATA[pbds平板电视，是一个封装了众多高效又实用（相对于STL）的数据结构的库，包括堆，平衡树，哈希表等。 介绍首先，在使用之前，你需要：12345#include &lt;ext/pb_ds/assoc_container.hpp&gt; #include &lt;ext/pb_ds/tree_policy.hpp&gt; //用tree#include &lt;ext/pb_ds/hash_policy.hpp&gt; //用hash#include &lt;ext/pb_ds/trie_policy.hpp&gt; //用trieusing namespace __gnu_pbds; 如果想麻烦的话，可以改成这样（但是CF会CE）：12#include &lt;bits/extc++.h&gt;using namespace __gnu_pbds; hashhash_table的用法和map类似，定义方法如下：12cc_hash_table&lt;string, int&gt; c;gp_hash_table&lt;string, int&gt; g; 其中cc开头的是拉链法，gp开头的是探测法，亲测后者会快一点顺带一提，这俩可能会比unordered_map快一点 treepbds里面的tree都是平衡树，其中有rb_tree, splay_tree, ov_tree（后两种都容易超时，所以请不要用它们）。 使用方法1234567891011121314tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;T //存储的类型null_type //无映射(低版本g++为null_mapped_type)less&lt;T&gt; //从小到大排序rb_tree_tag //红黑树tree_order_statistics_node_update //更新方式tr.insert(val); //插入;tr.erase(val); //删除; (参数可以是iterator）tr.order_of_key(val); //求排名 tr.find_by_order(x); //找k小值，返回迭代器(rank从0起算） tr.join(b); //将b并入tr，前提是两棵树类型一样且没有重复元素tr.split(v,b); //分裂，key小于等于v的元素属于tr，其余的属于b tr.lower_bound(x); //返回第一个大于等于x的元素的迭代器 tr.upper_bound(x); //返回第一个大于x的元素的迭代器 举个例子以下是洛谷P3369的代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace __gnu_pbds;using namespace std;typedef long long ll;tree&lt;ll, null_type, less&lt;ll&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;int main()&#123; int n; scanf("%d", &amp;n); for(int i = 1, op; i &lt;= n; ++i) &#123; ll k, ans; scanf("%d", &amp;op); scanf("%lld", &amp;k); if(op == 1) tr.insert((k&lt;&lt;20)+i); if(op == 2) tr.erase(tr.lower_bound(k&lt;&lt;20)); if(op == 3) printf("%d\n", tr.order_of_key(k&lt;&lt;20)+1); if(op == 4) printf("%lld\n", (*tr.find_by_order(k-1)) &gt;&gt; 20); if(op == 5) printf("%lld\n", (*(--tr.lower_bound(k&lt;&lt;20))) &gt;&gt; 20); if(op == 6) printf("%lld\n", (*tr.upper_bound((k&lt;&lt;20)+n)) &gt;&gt; 20); &#125; return 0;&#125; Trie使用方法Trie即字典树，定义方法如下：12345678910typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; tr;//第一个参数必须为字符串类型，tag也有别的tag，但pat最快，与tree相同，node_update支持自定义tr.insert(s); //插入s tr.erase(s); //删除s tr.join(b); //将b并入tr pair //pair的使用如下：pair&lt;tr::iterator,tr::iterator&gt; range=base.prefix_range(x);for(tr::iterator it=range.first;it!=range.second;it++) cout&lt;&lt;*it&lt;&lt;' '&lt;&lt;endl; //pair中第一个是起始迭代器，第二个是终止迭代器，遍历过去就可以找到所有字符串了。 举个例子这是一个例题代码：12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;using namespace std;using namespace __gnu_pbds; typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; Trie;int main()&#123; Trie base; base.insert("sun"); string x; while(cin &gt;&gt; x) &#123; if(x[0] == '?') &#123; cout &lt;&lt; x.substr(1) &lt;&lt; endl; auto range = base.prefix_range(x.substr(1)); int t = 0; for(auto it = range.first; t&lt;20 &amp;&amp; it!=range.second; it++, t++) cout &lt;&lt; " " &lt;&lt; *it &lt;&lt; endl; &#125; else base.insert(x.substr(1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康托展开]]></title>
    <url>%2F2020%2F01%2F31%2F%E5%BA%B7%E6%8B%93%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[康托展开可以用来求一个 $1 \sim n$ 的任意排列的排名。 康托展开时间复杂度康托展开可以在$O(n^2)$的复杂度内求出一个排列的排名，在使用树状数组或者线段树优化时可以做到$O(n\log n)$ 实现方法因为排列是按字典序排名的，因此越靠前的数字优先级越高。也就是说如果两个排列的某一位之前的数字都相同，那么如果这一位如果不相同，就按这一位排序。 比如$4$的排列，$[2,3,1,4] &lt; [2,3,4,1]$，是因为第$3$位的不同，故$[2,3,1,4]$在 $[2,3,4,1]$之前。 举个栗子取一段长度为$5$的排列$[2,5,4,3,1]$，大于以$1$为第一位的任何排列，以$1$为第一位的$5$的排列有$4!$种。这是非常好理解的。但是我们对第二位的$5$而言，它大于第一位与这个排列相同的，而这一位比$5$小的所有排列。不过我们要注意的是，这一位不仅要比$5$小，还要满足没有在当前排列的前面出现过，不然统计就重复了。因此这一位为$1,3$或$4$，第一位为$2$的所有排列都比它要小，数量为$3\times 3!$。 按照这样统计下去，答案就是$4!+3\times 3!+2!+1+1=46$，注意统计的是排名，故要在最后$+1$。 逆康托展开因为排列的排名和排列是一一对应的，所以康托展开满足双射关系，是可逆的。可以通过类似上面的过程倒推回来。 如果我们知道一个排列的排名，就可以推出这个排列。因为$4!$是严格大于$3\times 3! + 2\times 2! + 1\times 1$的，所以可以认为，对于长度为$5$的排列，$\lfloor\frac{rank}{4!}\rfloor$就是有多少个数小于这个排列的第一位。 引用上面的例子首先，$46-1=45$，即有$45$个排列比这个排列小。$\lfloor\frac{45}{4!}\rfloor = 1$，有一个数小于其首位，故首位为$2$。 此时让排名减去$4!$得到$21$，$\lfloor\frac{21}{3!}\rfloor = 3$，有三个数小于第二位，故第二位是$5$。 $21-3\times 3! = 3, \lfloor\frac{3}{2!}\rfloor = 1$，有一个数小于它，故第三位是$3$ $3-1\times 2! = 1$，有一个数小于它，那么第四位是$4$，最后剩下$1$ 最终我们得到原序列，即$[2,5,4,3,1]$。 实际上我们得到了若干形如有x个数小于y的结论，就知道它是当前第$x+1$个没有被选上的数，这里也可以用pbds的tree替罪羊树维护，时间复杂度为$O(n\log n)$]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流24题(Part.3)]]></title>
    <url>%2F2019%2F08%2F02%2FNetFlow24-3%2F</url>
    <content type="text"><![CDATA[这里是网络流24题建图的方法（题目来自洛谷）包含：P2774 洛谷P2774此题为最小割套路题 首先，将方格中的每个点进行染色（$(i+j) % 2 == 0$的为黑色，否则为白色） 可以发现，对于任意一个点，我们不能取它上下左右的四个点。于是就可以得到一张二分图，白色的点一个集合，黑色的点一个集合。 建立一个超级源点$S$和超级汇点$T$。 源点连向每一个黑色的点，流量为这个点的值；每一个白色的点连向汇点，流量为这个点的值。 每个黑色的点连向它相邻的白色的点，流量为$INF$。 从原点到汇点跑一次网络最大流，由于最大流 = 最小割，并且最大和 = 全局和 - 舍弃和，本题得解。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关数说事]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%85%B3%E6%95%B0%E8%AF%B4%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[整理一下数论中的奇奇怪怪的结论以及公式 欧拉定理欧拉函数的定义：小于$n$的正整数n中与$n$互质的数的个数，如$\phi(8) = 4$(1, 3, 5, 7均与8互质)若$gcd(a, p)=1$，则$a^{\phi(p)} \equiv 1(mod\;p)$，其中$\phi(p)$是欧拉函数 扩展欧拉定理$$a^{b} \equiv\begin{cases}a^{b\%\phi(p)} &amp; gcd(a, p)=1 \\a^{b} &amp; gcd(a, p) \neq 1, b &lt; n \\a^{b+b\%\phi(p)} &amp; gcd(a, p) \neq 1, b \geq n\end{cases}\quad (mod\;p)$$ 欧拉函数打表12345678910111213void phi_table()&#123; for(int i = 1; i &lt; N; ++i) phi[i] = 0; phi[1] = 1; for(int i = 2; i &lt; N; ++i) for(int j = i; j &lt; N; ++j) &#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i-1); &#125;&#125; 欧拉函数计算$$\phi (x) = x\prod_{i=1}^n (1-\frac{1}{p_i})$$ 1234567891011121314int euler_phi(int x)&#123; int ans = x, lim = (int)sqrt(x+0.5); for(int i = 2; i &lt;= lim; ++i) if(x%i == 0) &#123; ans = ans / i * (i-1); while(x%i == 0) x /= i; &#125; if(x &gt; 1) ans = ans / x * (x-1); return ans;&#125; 费马小定理若$p$是质数，且$gcd(a, b) = 1$，那么$a^{p-1} \equiv 1(mod\;p)$注意其逆命题不成立 中国剩余定理设正整数$m_1,\, m_2, \, m_3, \, … \, m_k$两两互质，则同余方程组 $$\begin{cases}x \equiv a_1(mod \; m_1) \\x \equiv a_2(mod \; m_2) \\x \equiv a_3(mod \; m_3) \\\qquad \vdots \\x \equiv a_k(mod \; m_k)\end{cases}$$ 有整数解。不妨设$M = \prod_{i=1}^k m_i, M_i = M / m_i, t_iM_i \equiv 1 (mod\; m_i)$那么这个方程组的通解为：$x = iM + \sum_{i=1}^k a_it_iM_i, k \in Z$在模$M$意义下，方程组有唯一解：$x = \sum_{i=1}^k a_it_iM_i$ 拓展中国剩余定理设正整数$m_1,\, m_2, \, m_3, \, … \, m_k$不一定两两互质，则同余方程组 $$\begin{cases}x \equiv a_1(mod \; m_1) \\x \equiv a_2(mod \; m_2) \\x \equiv a_3(mod \; m_3) \\\qquad \vdots \\x \equiv a_k(mod \; m_k)\end{cases}$$ 假设已经求出前$k-1$个同余式组成的同余方程组的解为$x$，且有$M = LCM_{i-1}^{k-1} m_i$防止爆long long 则前$k-1$个同余式组成的同余方程组的通解为$x + iM, i \in Z$ 那么对于加入第$k$个方程后的方程组，我们要求出一个整数$t$，使得$x+tM \equiv a_k(mod\; m_k)$ 移项得到$tM \equiv a_k-x(mod\; m_k)$ 对于上式，可以通过扩展欧几里得求解$t$，若这个同余式无解，则整个方程组无解；若有，则前$k$个同余式组成的同余方程组的一个解为$x_k = x+tM$ 所以整个算法的思路就是求k次扩展欧几里得 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// LuoguP4777// https://www.luogu.org/problem/P4777// -*- coding: utf-8 -*-// @Date : 2019-07-26 12:48:11#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 233;ll a[N], b[N];int n;ll mul(ll a, ll b, ll m)&#123; ll res = 0; while(b) &#123; if(b&amp;1) &#123; res += a; res %= m; &#125; a += a; a %= m; b &gt;&gt;= 1; &#125; return res;&#125;void exgcd(ll a, ll b, ll&amp; d, ll&amp; x, ll&amp; y)&#123; if(!b) &#123; x = 1; y = 0; d = a; &#125; else &#123; exgcd(b, a%b, d, y, x); y -= (a/b) * x; &#125;&#125;ll excrt()&#123; ll x, y; ll M = b[0]; ll ans = a[0]; for(int i = 1; i &lt; n; ++i) &#123; ll A = M; ll B = b[i]; ll C = (a[i] - ans%B + B) % B; ll gcd; exgcd(A, B, gcd, x, y); B /= gcd; if(C % gcd) return -1; x = mul(x, C/gcd, B); ans += x * M; M *= B; ans = (ans%M + M) % M; &#125; return (ans%M + M) % M;&#125;// #define localint main()&#123;#ifdef local freopen("data.in", "r", stdin); freopen("ans.out", "w", stdout);#endif scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%lld%lld", b+i, a+i); printf("%lld\n", excrt()); return 0;&#125; 蔡勒公式一个能够快速计算出某年某月某日是星期几的公式 令$Ans = (W+7) \; Mod \; 7$，则$Ans$的值从0-6对应星期日-星期六。在公式中，$c$为年份前两位，$y$为年份后两位，$m$为月份，$d$为日期有一点要注意，$m$的取值范围是$[3, 14]$，任意一年的1、2月份要当做上一年的13、14月来计算，例如：2003年1月1日需要看做2002年13月1日来计算 $$W =\begin{cases}y + \frac{y}{4} + \frac{c}{4} - 2c + \frac{26(m+1)}{10} + d - 1, &amp; \text{$After$ $1582$-$10$-$04$} \\y + \frac{y}{4} + \frac{c}{4} - 2c + \frac{26(m+1)}{10} + d + 2, &amp; \text{$Before$ $1582$-$10$-$04$}\end{cases}$$ 或者($y$是四位数的年份)： $$w = (d + 2m + \frac{3(m+1)}{5} + y + \frac{y}{4} - \frac{y}{100} + \frac{y}{400} + 1) \; Mod \; 7$$]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS]]></title>
    <url>%2F2019%2F07%2F25%2FBSGS%2F</url>
    <content type="text"><![CDATA[离散对数问题是这样一个问题，它要求解模方程$$a^n \equiv b (mod \; m)$$这里简单介绍下大步小步算法（Baby Step Giant Step）来解决。 m是质数的情况不妨设$x=A\lceil \sqrt{m} \rceil +B$，且$A\in[0, \sqrt{m}),\;B\in[0, \sqrt{m})$，（A、B均为整数）于是方程就变成了$$a ^ {A\lceil \sqrt{m} \rceil +B} \equiv b (mod \; m)$$ 可以在两边通识乘以$a^{B}$的逆元，由于$m$是质数，这个逆元一定存在，于是方程变成：$$a ^ {A\lceil \sqrt{m} \rceil } \equiv b \cdot a^{-B} (mod \; m)$$ 由于A、B都是$\sqrt{m}$级别的数，可以先计算右边这部分的值，存入Hash表map，然后计算左边的值，在Hash表中查找，只要按照从小到大的顺序如果有解就能够找到最小的解，由于两边只有$\sqrt{m}$个数，所以时间复杂度是$O(\sqrt{m})$的，这样$m$是质数的情况就解决了 一个优化：我们可以设$x=A\lceil \sqrt{m} \rceil -B$，且$A\in(0, \sqrt{m}+1],\;B\in[0, \sqrt{m})$，这样化简之后的方程就是：$$a ^ {A\lceil \sqrt{m} \rceil } \equiv b \cdot a^{B} (mod \; m)$$ 这样就可以不用求出逆元，但是这里只是不用求出逆元，但是仍然用到了逆元的存在性 m不是质数的情况同样地，设$x=A \lceil \sqrt{m} \rceil +B$，根据上面的推导，会发现需要用到的性质就是$a^{B}$的逆元存在，所以当$m$和$a$互质的时候上面的推论仍然成立。 当$gcd(a, m) \neq 1$时，我们要想办法把方程转化为$gcd(a, m) = 1$的情况 于是我们把模方程写成另一种形式：$$a^{x}+km=b,\quad k \in Z$$ 不妨设$g = gcd(a, m)$，这样的话若$g \nmid b$，那么方程一定无解，所以当$g \mid b$时，在方程左右两边同时除以$g$，得到：$$ \frac{a}{g}a^{x-1} + \frac{m}{g}k = \frac{b}{g},\quad k \in Z$$ 这样就消去了一个因子，得到方程：$$\frac{a}{g}a^{x-1} \equiv \frac{b}{g}(mod\,\frac{m}{g})$$ 令$X = \frac{m}{g},\;Y = \frac{b}{g}(\frac{a}{g})^{-1}$（这里不可以把$g$消掉），就可以得到新的方程：$$a^{x_1} \equiv Y(mod\;X)$$ 得到解之后得到原方程的解$x = x_1 + 1$，不断重复这个过程，最后一定会得到一个可以解出的方程，套用刚才的大步小步法解出后即可。要注意的是这个过程中如果某一步发现$Y = 1$，那么就可以退出，因为此时已经得到了解。 上面这个过程是可能重复执行的，举个栗子：$(a, m) = (6, 16) \to (6, 8) \to (6, 4) \to (6, 2)$ 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* BZOJ-2480: Spoj3105 Mod * 扩展大步小步 */#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;using ll = long long;int mod_pow(ll x, ll p, ll mod_v)&#123; ll v = 1; while(p) &#123; if(p &amp; 1) v = x * v % mod_v; x = x * x % mod_v; p &gt;&gt;= 1; &#125; return v;&#125;int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125;int baby_step_giant_step(int a, int b, int p)&#123; a %= p, b %= p; if(b == 1) return 0; int cnt = 0; ll t = 1; for(int g = gcd(a, p); g != 1; g = gcd(a, p)) &#123; if(b % g) return -1; p /= g, b /= g, t = t * a / g % p; ++cnt; if(b == t) return cnt; &#125; map&lt;int, int&gt; hash; int m = int(sqrt(1.0 * p) + 1); ll base = b; for(int i = 0; i != m; ++i) &#123; hash[base] = i; base = base * a % p; &#125; base = mod_pow(a, m, p); ll now = t; for(int i = 1; i &lt;= m + 1; ++i) &#123; now = now * base % p; if(hash.count(now)) return i * m - hash[now] + cnt; &#125; return -1;&#125;int main()&#123; int a, b, p; while(scanf("%d %d %d", &amp;a, &amp;p, &amp;b), p) &#123; int ans = baby_step_giant_step(a, b, p); if(ans == -1) puts("No Solution"); else printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉回路]]></title>
    <url>%2F2019%2F04%2F25%2FEulerPath%2F</url>
    <content type="text"><![CDATA[如果图中的一个路径包括每个边恰好一次，则该路径称为欧拉路径。 欧拉回路是数学家欧拉在研究著名的德国哥尼斯堡七桥问题时发现的。 几条规律定义 顶点与指数：设一个平面图形是由有限个点及有限条弧组成的，这些点称为图形的顶点，从任一顶点引出的该图形的弧的条数，称为这个顶点的指数。 奇顶点：指数为奇数的顶点。 偶顶点：指数为偶数的顶点 结论 凡是由偶点组成的连通图，一定可以一笔画成。画时可以把任一偶点为起点，最后一定能以这个点为终点画完此图。 凡是只有两个奇点的连通图（其余都为偶点），一定可以一笔画成。画时必须把一个奇点为起点，另一个奇点终点。 其他情况的图都不能一笔画出。（有偶数个奇点除以二便可算出此图需几笔画成。） 算法简述核心代码不长，（本质上就是个DFS）不妨设图$G = {V, E}$，当前节点为$i$，$&lt;i, j&gt; \in E$然后将$&lt;i, j&gt;$从$E$中删去，然后将当前节点变更为$j$，重复上述操作直至无法继续进行操作或当前节点的指数为$0$为止。 CF1152E这就是个板子题，直接按题目来建图，然后跑欧拉回路就行了 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const vector&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const set&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;struct EulerPath&#123; map&lt;int, multiset&lt;int&gt; &gt; g; vector&lt;int&gt; pth; vector&lt;int&gt; odd; EulerPath() &#123; map&lt;int, multiset&lt;int&gt; &gt;().swap(g); vector&lt;int&gt;().swap(odd); vector&lt;int&gt;().swap(pth); &#125; void sol(int x) &#123; while(g[x].size()) &#123; int val = *g[x].begin(); g[x].erase(g[x].begin()); g[val].erase(g[val].find(x)); sol(val); &#125; pth.push_back(x); &#125; void addedge(int x, int y) &#123; g[x].insert(y); g[y].insert(x); &#125; bool get_path(int length) &#123; for(auto i: g) if(i.second.size()&amp;1) odd.push_back(i.first); if(odd.size() &gt; 2) return false; if(odd.size()) sol(odd[0]); else sol(g.begin()-&gt;first); reverse(pth.begin(), pth.end()); return pth.size() == length; &#125;&#125;solver;const int N = 1e5 + 233;int a[N], b[N];// #define localint main()&#123;#ifdef local freopen("data.in", "r", stdin); freopen("ans.out", "w", stdout);#endif int n; scanf("%d", &amp;n); for(int i = 1; i &lt; n; ++i) scanf("%d", a+i); for(int i = 1; i &lt; n; ++i) scanf("%d", b+i); for(int i = 1; i &lt; n; ++i) &#123; if(a[i] &gt; b[i]) &#123; cout &lt;&lt; "-1\n"; exit(0); &#125; solver.addedge(a[i], b[i]); &#125; if(solver.get_path(n)) cout &lt;&lt; solver.pth &lt;&lt; endl; else cout &lt;&lt; "-1\n"; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0/1分数规划]]></title>
    <url>%2F2019%2F04%2F15%2F01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[SCU2992现有n个物品，每个物品有两个权值a和b，现要从中选出k件物品，使得$\frac{\sum_{i=0}^k a_i}{\sum_{i=0}^k b_i}$ 的值最大。 分析不妨设$$A = \sum_{i=0}^k a_i, B = \sum_{i=0}^k b_i, ans = \frac{A}{B}$$ 那么 $$ A-ans*B = 0 $$ 展开，得每个物品的贡献为$$a_i-ans*b_i$$ 然后排个序，取出贡献最高的前k件物品，累加得到一个贡献和$total$，若$total \leq 0$，则ans可以向左侧移动，否则向右侧移动。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const vector&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const set&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;inline T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;const double EPS = 1e-4;const int N = 1e4 + 233;ll a[N], b[N];double f[N];int n, k;bool chck(double x)&#123; ll sa = 0; ll sb = 0; for(int i = 0; i &lt; n; ++i) f[i] = 1.0 * (a[i] - b[i] * x); sort(f, f+n, greater&lt;double&gt;()); double res = 0.0; for(int i = 0; i &lt; n-k; ++i) res += f[i]; return res &gt; 0;&#125;// #define localint main()&#123;#ifdef local freopen("data.in", "r", stdin); freopen("ans.out", "w", stdout);#endif while(~scanf("%d%d", &amp;n, &amp;k)) &#123; if(n == 0 &amp;&amp; k == 0) break; for(int i = 0; i &lt; n; ++i) a[i] = read&lt;ll&gt;(); for(int i = 0; i &lt; n; ++i) b[i] = read&lt;ll&gt;(); double l = 0.0; double r = 1.0; while(r-l &gt;= EPS) &#123; double mid = (l+r) / 2.0; if(chck(mid)) l = mid; else r = mid; &#125; printf("%d\n", static_cast&lt;int&gt;(round(100.0 * l))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流24题(Part.2)]]></title>
    <url>%2F2019%2F04%2F12%2FNetFlow24-2%2F</url>
    <content type="text"><![CDATA[这里是网络流24题建图的方法（题目来自洛谷）包含：P2763, P2764, P2765, P2766, P2770 网络流24题(Part.2)洛谷P2763此题为MaxFlow 对于每一道题，在它和它的所有适用类型之间连边 新建一个超级源点，将它和所有题目相连 新建一个超级汇点，将所有类型和它相连 打印方案遍历边集 当且仅当流向汇点的弧不满载时无解 洛谷P2764此题为MaxFlow建图方式题面已经给出，简单概括一下： 搞成二分图 给出的所有边改为在左集和右集之间连接 另建源点与左集，汇点与右集相连 打印方案时，在找到增广路之后记录一下路径即可 Tips贴个结论：最小路径覆盖数目 = 顶点数 - 最大匹配 洛谷P2765此题为玄学打表找规律由打表发现，对于总共$n$个柱子，能够放下的总球数为$(n*(n+2)+(n\&amp;1)-2)/2$ 然后直接贪心就行了，时间复杂度$O(nm)$ 此题为最小路径覆盖 把每个球拆成两个，（左右各一） 对于任意的$i &lt; j$，且$i+j$是完全平方数，那么从左集的$i$到右集的$j$连一条边 由于节点数量不固定，就一个个点往上加（直到最小路径覆盖数超过柱子数目时结束加点） 扫一遍边集，把不和源点/汇点的链接的、流量为1的边记录下来，然后通过并查集合并一下，得到方案。 洛谷P2766此题为网络最大流 首先用DP求解$f[i]$，表示以$i$开头的LCS长度，求出$max{f[i]}$。 把序列中的每个点拆成两个$i_a$和$i_b$，并从$i_a$到$i_b$之间连一条容量为1的弧 建立源点$S$和汇点$T$，对于任意的$f[i]=k$，从$i_b$到$T$建一条容量为1的弧。 对于任意的$f[i]=1$，从$S$到$i_a$建一条容量为1的弧。 如果$i&lt;j, a[i] \leq a[j]$并且$f[i]+1=f[j]$，那么从$i_b$到$j_a$建一条容量为1的弧。 求出的网络最大流，就是第二问的结果；把边$&lt;1_a,1_b&gt;, &lt;n_a, n_b&gt;, &lt;S, 1_a&gt;, &lt;n_b, T&gt;$的容量修改为$INF$，再求一次网络最大流，就是第三问的结果。 洛谷P2770此题为最小最大费用流 本题需要求从起点到终点再到起点的最长路，即从起点到终点跑两次。 由于每个城市只能经过一次，那么老规矩，拆点。对于城市$i$，将其拆成$i_a, i_b$两个点，从$i_a$到$i_b$连一条容量为1，费用为-1的弧。 对起点$s$和终点$t$，要额外建一条容量为1，费用为0的弧（因为起点和终点都需要经过两次） 如果城市$i$到城市$j$有一条航线，那么在$i_b$和$j_a$之间建一条容量为1，费用为0的边。 增加一条从源点$S$到出发点$s_a$的，容量为2，费用为0的弧，和一条从终点$t_b$到汇点$T$的容量为2，费用为0的弧。然后跑最小费用流即可。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>MCMF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流24题(Part.1)]]></title>
    <url>%2F2019%2F04%2F10%2FNetFlow24-1%2F</url>
    <content type="text"><![CDATA[这里是网络流24题建图的方法（题目来自洛谷）包含：P1251, P2754, P2756, P2761, P2762 网络流24题(Part.1)洛谷P1251此题为MCMF首先，将一天拆成晚上和早上，每天晚上会受到脏餐巾（来源：当天早上用完的餐巾，在这道题中可理解为从原点获得），每天早上又有干净的餐巾（来源：购买、快洗店、慢洗店。） 从原点向每一天晚上连一条流量为当天所用餐巾x，费用为0的边，表示每天晚上从起点获得x条脏餐巾。 从每一天早上向汇点连一条流量为当天所用餐巾x，费用为0的边，每天白天,表示向汇点提供x条干净的餐巾,流满时表示第i天的餐巾够用。 从每一天晚上向第二天晚上连一条流量为INF，费用为0的边，表示每天晚上可以将脏餐巾留到第二天晚上（注意不是早上，因为脏餐巾在早上不可以使用）。 从每一天晚上向这一天+快洗所用天数$t_1$的那一天早上连一条流量为INF，费用为快洗所用钱数的边，表示每天晚上可以送去快洗部,在地$i+t_1$天早上收到餐巾。 同理，从每一天晚上向这一天+慢洗所用天数$t_2$的那一天早上连一条流量为INF，费用为慢洗所用钱数的边，表示每天晚上可以送去慢洗部,在地$i+t_2$天早上收到餐巾 。 从起点向每一天早上连一条流量为INF，费用为购买餐巾所用钱数的边，表示每天早上可以购买餐巾。 洛谷P2754此题为MaxFlow将每一个星球按时间拆点，不妨将第i个星球在第j时刻的状态表示为$(i, j)$，$path_{i, j}$表示第i艘飞船当前在第j站，第i艘飞船的运行周期为$t_i$。则有： 首先判断时候存在解（并查集），若不存在，判0结束。否则执行下面的步骤： 由于每个星球上的人有两个选择：要么上飞船（如果有），要么等一个单位的时间。所以建两条边$(path_{i, j}, j) \rightarrow (path_{i, (j+1) \% t_i}, j+1)$，$(i, j) \rightarrow (i, j+1)$。 在当前时刻j，建立一条从源点到起点（地球）的边，即：$Source\rightarrow (earth, j)$ 在当前时刻j，建立一条从终点（月球）到汇点的边，即：$(moon, j)\rightarrow Sink$ 一旦此网络的流量等于k，结束加边过程，给出答案。 Tips 这题需要一边加边一边跑最大流，即：每增加一次当前时刻，加边，然后跑最大流 每次跑最大流时，在上次残量网络的基础上跑（千万不要清空残量网络） 洛谷P2756此题为MaxFlow(二分图) 整一个超级源点和超级汇点，超级源点连左集中所有节点，右集所有节点连向超级汇点；然后就按题目给的边连上就行。 跑Dinic，完了以后检索边集，发现有流量的边就输出。（注意下不要把含有源点和汇点的输出来） 洛谷P2761此题为状压、SPFA(什么鬼?) 可以将每个状态用一个整数表示$(n \leq 20)$ 没有必要把所有边全部存下来，只需要在跑SPFA时确定是否能够转移即可。 洛谷P2762此题为最小割-最大流定理 建边：$S \rightarrow E_i, E_i \rightarrow I_j, I_j \rightarrow T$(其中S为源点，$E_i$为第i个实验，$I_i$为第i件设备) 建好的图大概是这样：（图片由SSL_XXY_BlackCloud$julao$制作） 最终答案为最后一次BFS是仍然能够访问到的点（其他节点都被割掉了）]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Dinic</tag>
        <tag>SPFA</tag>
        <tag>MCMF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miller-Rabin & Pollard-Rho]]></title>
    <url>%2F2019%2F04%2F04%2FMiller-Rabin%26Pollard-Rho%2F</url>
    <content type="text"><![CDATA[Miller-Rabin是一种能够快速判定素数的算法，其时间复杂度为$O(logn)$Pollard-Rho是一种能够快速进行质因数分解的算法，其时间复杂度为$O(n^{1/4})$，空间复杂度为$O(logn)$。 算法介绍以下内容来自zbx大佬的PPT Miller-Rabin 偶数单独处理，否则设$n=2^t×m+1$;任选一个整数a，对$k=0,1,2,…,t$分别计算$a^{2^k*m}%n$的值$a(k)$;对于某个k，如果$a(k)=1$，但$a(k-1)$既不是1也不是n−1，则n是合数；如果$a(t)$仍然不是1，则n是合数；否则，n通过了基于a的测试，可以另选一个整数a继续测试。每一轮测试时间复杂度$O(logn)$，进行c轮时间复杂度$O(clogn)$。 $n\leq2^{32}$时，只需检测$a=2,7,61$，即可确保正确，即$c=3$；$n\leq2^{64}$时，只需检测$a=2,3,5,7,11$，即可确保正确，即$c=5$。n特别大时，随机选一个a进行测试，合数通过测试的概率低于$\frac{1}{4}$，合数通过c轮测试的概率低于$\frac{1}{4^c}$，适当设定测试次数即可。 Pollard-Rho 先用Miller-Rabin算法确定n是合数；随机整数$x_0$和a，生成一个序列$x_{i+1}=(x_i^2+a)%n$；对$i=1,2,3…$分别计算$p=gcd⁡(\mid x_{2i}−x_{i}\mid,n)$，当$x_{2i}=x_{i}$时停止并重新随机生成$x_0$和a；如果$p\not=1$则找到了n的一个约数p，递归处理p和n/p。时间复杂度$O(n^{1/4})$，空间复杂度$O(log⁡n)$。 时间复杂度的计算：设$n=pq,p\leq q$，序列$y_i \equiv x_i(mod p)$；根据生日悖论，${y_i}$周期期望长度$O(\sqrt p)$，${x_i}$周期期望长度$O(\sqrt n)$，不妨假设${y_i}$周期短；设${y_i}$周期为t，则$x_2t$与$x_t$还没进入周期，计算$gcd(\mid x_{2t}−x_t\mid, n)$可以得到p。 代码UPD::突然发现这个居然过不了板子题，重构了这个并且加了一堆玄学优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class PollardRho&#123;private: class MillerRabin &#123; private: static const int Pcnt = 12; const int P[Pcnt] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 61, 2333, 4567, 24251&#125;; inline ll Qpow(ll x, ll y, const ll&amp; X) &#123; ll t = 1; while(y) &#123; if(y&amp;1) t = Qmul(t, x, X); x = Qmul(x, x, X); y &gt;&gt;= 1; &#125; return t; &#125; inline bool Check(const ll&amp; x,const int&amp; p) &#123; if(!(x%p) || Qpow(p%x,x-1,x)^1) return false; ll k = x-1, t; while(!(k&amp;1)) &#123; t = Qpow(p%x, k&gt;&gt;=1, x); if(t^1 &amp;&amp; t^(x-1)) return false; if(!(t^(x-1))) return true; &#125; return true; &#125; public: bool isPrime(const ll&amp; x) &#123; if(x &lt; 2) return false; for(int i = 0; i^Pcnt; ++i) &#123; if(!(x^P[i])) return true; if(!Check(x, P[i])) return false; &#125; return true; &#125; inline ll Qmul(const ll&amp; x, const ll&amp; y, const ll&amp; X) &#123; ll k, t; k = (ll)((1.0L*x*y) / (1.0L*X)); t = x*y - k*X; t -= X; while(t &lt; 0) t += X; return t; &#125; &#125;MR; #define Rand(x) (1ll*rand()*rand()*rand()*rand()%(x) + 1) ll ans; inline ll gcd(const ll&amp; x,const ll&amp; y) &#123; return y? gcd(y, x%y): x; &#125; inline ll work(const ll&amp; x, const int&amp; y) &#123; int t = 0, k = 1; ll v0 = Rand(x-1), v = v0, d, s = 1; while(true) &#123; v = (MR.Qmul(v, v, x) + y) % x; s = MR.Qmul(s, abs(v-v0), x); if(!(v^v0) || !s) return x; if(++t == k) &#123; d = gcd(s, x); if(d^1) return d; v0 = v; k &lt;&lt;= 1; &#125; &#125; &#125; inline void Resolve(ll x, int t) &#123; if(!(x^1) || x &lt;= ans) return ; if(MR.isPrime(x)) &#123; facts.insert(x); return ; &#125; ll y = x; while(y == x) y = work(x, t--); while(!(x%y)) x /= y; Resolve(x, t); Resolve(y, t); &#125;public: set&lt;ll&gt; facts; inline PollardRho() &#123; srand(time(NULL)); &#125; inline void GetFact(const ll x) &#123; set&lt;ll&gt;().swap(facts); Resolve(x, 302627441); &#125;&#125;solver;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[次小生成树]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[次小生成树，即把所有生成树按权值从小到大排列，排在第二位生成树。（如果最小生成树不唯一，次小生成树的权值和最小生成树相等） 算法介绍显然，次小生成树必然是经过最小生成树加一条边后删一条边得到的。 最容易想到的方法就是暴力。 由于次小生成树不会和最小生成树完全相同，所以我们求出最小生成树后，依次枚举不出现在次小生成树上的边，然后对n-1张“缺一条边的图”求一次最小生成树。这n-1棵树中权值最小的树即为次小生成树。 然而，暴力法的时间复杂度$O(mn\alpha(n, m))$是大部分情况下是无法接受的。 还有一种更好的方法：枚举要加入哪条新边。在最小生成树上添加一条新边$&lt;u, v&gt;$之后，图上会出现一条回路，因此删除的边必须在最小生成树上u到v的路径上，并且删去的边的权值必然是最大的。总时间复杂度为$O(n^2)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const vector&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const set&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;struct edge&#123; int f, t, c; bool vis; edge(int f = 0, int t = 0, int c = 0): f(f), t(t), c(c), vis(false)&#123;&#125; bool operator &lt; (const edge&amp; cmp) const &#123; if(c == cmp.c) &#123; if(f == cmp.f) return t &lt; cmp.t; return f &lt; cmp.f; &#125; return c &lt; cmp.c; &#125; void read() &#123; f = ::read&lt;int&gt;(); t = ::read&lt;int&gt;(); c = ::read&lt;int&gt;(); &#125;&#125;;const int M = 1e3 + 233;const int N = 1e6 + 666;const int INF = 1e9 + 7;edge a[N];int fa[M], n, m;vector&lt;int&gt; g[M];int maxd[M][M];int found(int x)&#123; return x == fa[x]? x: fa[x] = found(fa[x]);&#125;void kruskal()&#123; for(int i = 0; i &lt;= n; ++i) &#123; g[i].clear(); g[i].push_back(i); fa[i] = i; &#125; int sumn = 0, cnt = 0; for(int i = 0; i &lt; m; ++i) &#123; if(cnt == n-1) break; int x = found(a[i].f); int y = found(a[i].t); if(x != y) &#123; cnt++; a[i].vis = true; sumn += a[i].c; for(auto j: g[x]) for(auto k: g[y]) maxd[j][k] = maxd[k][j] = a[i].c; fa[x] = y; for(auto j: g[x]) g[y].push_back(j); &#125; &#125; if(cnt &lt; n-1) &#123; printf("No MST\n"); return ; &#125; int temp = INF; for(int i = 0; i &lt; m; ++i) if(!a[i].vis) temp = min(temp, sumn + a[i].c - maxd[a[i].f][a[i].t]); printf("%d\n", temp);&#125;// #define localint main()&#123;#ifdef local freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif n = read&lt;int&gt;(); m = read&lt;int&gt;(); for(int i = 0; i &lt; m; ++i) a[i].read(); sort(a, a+m); kruskal(); return 0;&#125; Tips这种方法也可以用于判定最小生成树的唯一性。（当次小生成树的权值与最小生成树相等时，最小生成树不唯一）]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay树]]></title>
    <url>%2F2019%2F03%2F28%2FSplay-Tree%2F</url>
    <content type="text"><![CDATA[伸展树（Splay Tree），也叫分裂树，是一种二叉排序树。平均情况下，它能在$O(log N)$ 极端情况下为O(N) 内完成插入、查找和删除操作。其优势在于不需要记录平衡树的冗余信息。 简介现要维护一个序列${A_n}$(所有$A_i$初值为0)，要求支持如下操作(bzoj1251)： 对于区间$[L, R]$上的每一个元素，其值增加$val$ 对于区间$[L, R]$翻转这段区间上的元素 查询区间$[L, R]$上的最大值 由于翻转操作的存在，导致使用线段树维护变的困难，所以这里使用splay进行维护。 对于每次操作，我们将下标为L-1的节点旋转至树根，将下标为R+1的节点旋转至树根的右儿子，由于splay树的有序性，区间[L, R]就是R+1的左子树。 旋转操作Zig(将x节点右旋至根节点，Zag操作反之): Zig-Zig(对x节点进行两次右旋操作，使其到达根节点): Zig-Zag(对x节点线进行左旋，在进行右旋操作，使其到达根节点): 需要注意的是，splay树永远满足如下性质： 对于任意节点（不妨设其下标为x)，设其左儿子（如有）的下标为L，其右儿子（如有）的下标为R，则有：$L &lt; x &lt; R$ 旋转操作永远不会改变这一性质(具体操作见代码中的rotate函数)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;assert.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;struct splay_tree&#123; static const int N = 1e5 + 233; static const int INF = 1e9 + 7; struct node &#123; int val, Max, add, sz, son[2]; bool rev; void init(int _val) &#123; val = Max = _val; add = rev = son[0] = son[1] = 0; sz = 1; &#125; &#125;; node T[N]; int fa[N], root; // 重新获取节点信息 void pushup(int x) &#123; T[x].Max = T[x].val; T[x].sz = 1; if(T[x].son[0]) &#123; T[x].Max = max(T[x].Max, T[T[x].son[0]].Max); T[x].sz += T[T[x].son[0]].sz; &#125; if(T[x].son[1]) &#123; T[x].Max = max(T[x].Max, T[T[x].son[1]].Max); T[x].sz += T[T[x].son[1]].sz; &#125; &#125; // 下放标记 void pushdown(int x) &#123; if(x == 0) return ; if(T[x].add) &#123; if(T[x].son[0]) &#123; T[T[x].son[0]].val += T[x].add; T[T[x].son[0]].add += T[x].add; T[T[x].son[0]].Max += T[x].add; &#125; if(T[x].son[1]) &#123; T[T[x].son[1]].val += T[x].add; T[T[x].son[1]].add += T[x].add; T[T[x].son[1]].Max += T[x].add; &#125; T[x].add = 0; &#125; if(T[x].rev) &#123; if(T[x].son[0]) T[T[x].son[0]].rev ^= 1; if(T[x].son[1]) T[T[x].son[1]].rev ^= 1; swap(T[x].son[0], T[x].son[1]); T[x].rev = 0; &#125; &#125; // kind = 0时左旋，kind = 1时右旋 void rotate(int x, int kind) &#123; int y = fa[x]; int z = fa[y]; T[y].son[!kind] = T[x].son[kind]; fa[T[x].son[kind]] = y; T[x].son[kind] = y; fa[y] = x; T[z].son[T[z].son[1] == y] = x; fa[x] = z; pushup(y); &#125; // 将节点x旋转至goal位置 void splay(int x, int goal) &#123; if(x == goal) return ; while(fa[x] != goal) &#123; int y = fa[x]; int z = fa[y]; pushdown(x); pushdown(y); pushdown(z); int rx = T[y].son[0] == x; int ry = T[z].son[0] == y; if(z == goal) rotate(x, rx); else &#123; if(rx == ry) rotate(y, ry); else rotate(x, rx); rotate(x, ry); &#125; &#125; pushup(x); if(goal == 0) root = x; &#125; // 返回下标为pos的节点在树的位置 int select(int pos) &#123; int u = root; pushdown(u); while(T[T[u].son[0]].sz != pos) &#123; if(pos &lt; T[T[u].son[0]].sz) u = T[u].son[0]; else &#123; pos -= T[T[u].son[0]].sz + 1; u = T[u].son[1]; &#125; pushdown(u); &#125; return u; &#125; // 查询、修改操作相关 int pre_sol(int l, int r) &#123; int u = select(l-1); int v = select(r+1); splay(u, 0); splay(v, u); return v; &#125; void update(int l, int r, int val) &#123; int v = pre_sol(l, r); T[T[v].son[0]].Max += val; T[T[v].son[0]].val += val; T[T[v].son[0]].add += val; &#125; void reverse(int l, int r) &#123; int v = pre_sol(l, r); T[T[v].son[0]].rev ^= 1; &#125; int query(int l, int r) &#123; int v = pre_sol(l, r); return T[T[v].son[0]].Max; &#125; int build(int l, int r) &#123; if(l &gt; r) return 0; if(l == r) return l; int mid = (l+r) &gt;&gt; 1, sl, sr; T[mid].son[0] = sl = build(l, mid-1); T[mid].son[1] = sr = build(mid+1, r); fa[sl] = fa[sr] = mid; pushup(mid); return mid; &#125; // 预处理，注意三个-INF的边界处理 void init(int n) &#123; T[0].init(-INF); T[1].init(-INF); T[n+2].init(-INF); for(int i = 2; i &lt;= n+1; ++i) T[i].init(0); root = build(1, n+2); fa[root] = 0; fa[0] = 0; T[0].son[1] = root; T[0].sz = 0; &#125;&#125;;splay_tree solver;// #define localint main()&#123;#ifdef local freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif int n = read&lt;int&gt;(); int m = read&lt;int&gt;(); solver.init(n); for(int i = 0; i &lt; m; ++i) &#123; int a, b, c, d; a = read&lt;int&gt;(); b = read&lt;int&gt;(); c = read&lt;int&gt;(); if(a == 1) &#123; d = read&lt;int&gt;(); solver.update(b, c, d); &#125; else if(a == 2) solver.reverse(b, c); else printf("%d\n", solver.query(b, c)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>区间维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManaCher算法]]></title>
    <url>%2F2019%2F03%2F25%2FManaCher%2F</url>
    <content type="text"><![CDATA[Manacher算法是查找一个字符串的最长回文子串的线性算法。其时间复杂度为$O(n)$ 算法介绍由于存在奇回文与偶回文两种类型的回文串，分开判断较为复杂，所以将二者全部处理成奇回文。(以下内容来自Sundes大佬的PPT) 考虑将原字符串StrA进行预处理，不妨在字符串首尾位置以及任意两字符之间插入一个原本不存在于StrA中的字符。得到字符串StrB，经过这样处理后所有的回文都变成了奇回文，且回文性质不变。如:$$bob –&gt; #b#o#b#$$$$noon –&gt; #n#o#o#n#$$$$level –&gt; #l#e#v#e#l#$$由于第一个和最后一个字符都是#号，且也需要搜索回文，为了防止越界，我们还需要在首尾再加上非#号字符，实际操作时我们只需给开头加上个非#号字符，结尾不用加的原因是字符串的结尾标识为’\0’，等于默认加过了。不妨在字符串首插入字符’\$’$$bob –&gt; $#b#o#b#$$$$noon –&gt; $#n#o#o#n#$$$$level –&gt; $#l#e#v#e#l#$$通过以上预处理，字符串StrA转化为了字符串StrB。 记数组p[max_len]，p[i]表示StrB以i位置的字符为中心点，最长回文子串的半径大小 (即回文长度(len-1)/2) ，注意max_len最少应为原字符串StrA长度两倍加一。通过p数组我们就可以找到其最大值和其位置，就能确定最长回文子串了，那么下面我们就来看如何求p数组，需要新增两个辅助变量mx和id，其中id为最大回文子串中心的位置，mx是回文串能延伸到的最右端的位置。(即id+p[id])这个算法的最核心的一行如下：$$p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;$$ 下面详细介绍该转移方程的内涵当 mx - i &gt; p[j] 的时候，以StrB[j]为中心的回文子串包含在以StrB[id]为中心的回文子串中，由于 i 和 j 对称，以StrB[i]为中心的回文子串必然包含在以StrB[id]为中心的回文子串中，所以必有 $P[i] = P[j]$，见下图。 当 $P[j] &gt;= mx - i$ 的时候，以StrB[j]为中心的回文子串不完全包含于以StrB[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以StrB[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 $P[i] &gt;= mx - i$。至于mx之后的部分是否依旧对称，则需要朴素的对比。在此过程中维护mx与id。（若回文串能延伸到的最右端的位置大于mx，则修改mx与id） 对于 $mx &lt;= i$ 的情况，无法对 P[i]做更多的假设，只能$P[i] = 1$，然后再去匹配了。由于每一个位置最多只会被朴素的匹配一次，所以算法复杂程度$O(n)$; 代码12345678910111213141516171819202122int manacher()&#123; int len = strlen(s); int maxr = 0, mid = 0; for(int i = 1; i &lt; len; ++i) &#123; if(i &lt; maxr) val[i] = min(val[(mid&lt;&lt;1) - i], maxr-i); else val[i] = 1; while(s[i-val[i]] == s[i+val[i]]) val[i]++; if(val[i] + i &gt; maxr) &#123; maxr = val[i] + i; mid = i; &#125; printf("%d ", val[i]); &#125; return (*max_element(val, val+len)) - 1;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老司机树]]></title>
    <url>%2F2019%2F03%2F24%2FODT%2F</url>
    <content type="text"><![CDATA[老司机树(ODT，又名Chtholly Tree，珂朵莉树), 由ODT大佬提出。 简介来源：Codeforces896C对于一个序列，随机地进行一系列包含推平一段区间在内的操作，可以采用这种数据结构 其核心思想为，将每一段值相等的子序列用一个三元组$(l, r, val)$表示，由于“推平一段区间”操作的存在且操作是随机的，所以三元组序列的长度将趋近于$log n$。 对于每次操作$[L, R]$，将包含待L或R的三元组$(x, y, val)$分成两个三元组$(x, L-1, val)$, $(L, y, val)$, 使得$L, R$处于三元组的左边界，然后对区间内部的三元组进行暴力维护。 顺带提一句，如果使用set维护三元组的话，由于set内部的元素一旦插入就不可更改，所以成员变量应当使用mutable关键字声明。 注意如果值的更改使得元素的优先级发生了变化，将导致set内部元素不再有序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const vector&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const set&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;class node&#123; public: mutable ll l, r, val; node(ll l = 0, ll r = 0, ll val = 0): l(l), r(r), val(val)&#123;&#125; bool operator &lt; (const node&amp; cmp) const &#123; if(l == cmp.l) return r &lt; cmp.r; return l &lt; cmp.l; &#125; &#125;;class heapnode&#123; public: ll len, val; heapnode(ll len = 0, ll val = 0): len(len), val(val)&#123;&#125; bool operator &lt; (const heapnode&amp; cmp) const &#123; if(val == cmp.val) return len &lt; cmp.len; return val &lt; cmp.val; &#125;&#125;;const ll MOD = 1e9 + 7;const int N = 1e5 + 233;ll dig[N], seed, n, m, op, vm, l, r, x, y;set&lt;node&gt; s;vector&lt;heapnode&gt; v;ll rnd()&#123; ll ret = seed; seed = (seed * 7 + 13) % MOD; return ret;&#125;void getData()&#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;seed, &amp;vm); for(int i = 1; i &lt;= n; ++i) dig[i] = (rnd() % vm) + 1;&#125;void getOp()&#123; op = (rnd() % 4) + 1; l = (rnd() % n) + 1; r = (rnd() % n) + 1; x = y = 0; if(l &gt; r) swap(l, r); if(op == 3) x = (rnd() % (r-l+1)) + 1; else x = (rnd() % vm) + 1; if(op == 4) y = (rnd() % vm) + 1; &#125;set&lt;node&gt;::iterator split(int pos)&#123; auto p = s.lower_bound(node(pos)); if(p != s.end() &amp;&amp; p-&gt;l == pos) return p; p--; if(pos &gt; p-&gt;r) return s.end(); ll l = p-&gt;l; ll r = p-&gt;r; ll v = p-&gt;val; s.erase(p); s.emplace(l, pos-1, v); return s.emplace(pos, r, v).first;&#125;ll fp(ll x, ll y, ll mod)&#123; ll res = 1; x %= mod; while(y) &#123; if(y&amp;1) res *= x; x *= x; x %= mod; res %= mod; y &gt;&gt;= 1; &#125; return res;&#125;// #define localint main()&#123;#ifdef local freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif getData(); for(int i = 1; i &lt;= n; ++i) s.emplace(i, i, dig[i]); while(m--) &#123; getOp(); split(l); auto sr = split(r+1); auto sl = split(l); switch(op) &#123; case 1: &#123; for(; sl != sr; ++sl) sl-&gt;val += x; break; &#125; case 2: &#123; s.erase(sl, sr); s.emplace(l, r, x); break; &#125; case 3: &#123; vector&lt;heapnode&gt;().swap(v); bool ok = false; for(; sl != sr; ++sl) v.emplace_back(sl-&gt;r - sl-&gt;l + 1, sl-&gt;val); sort(v.begin(), v.end()); for(auto i: v) &#123; x -= i.len; if(x &lt;= 0) &#123; printf("%I64d\n", i.val); ok = true; break; &#125; &#125; assert(ok); break; &#125; case 4: &#123; ll res = 0; while(sl != sr) &#123; ll temp = (sl-&gt;r - sl-&gt;l + 1) * fp(sl-&gt;val, x, y); temp %= y; res += temp; res %= y; sl++; &#125; printf("%I64d\n", res); break; &#125; default: assert(false); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>区间维护</tag>
      </tags>
  </entry>
</search>
