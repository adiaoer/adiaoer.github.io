<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Miller-Rabin & Pollard-Rho]]></title>
    <url>%2F2019%2F04%2F04%2FMiller-Rabin%26Pollard-Rho%2F</url>
    <content type="text"><![CDATA[Miller-Rabin是一种能够快速判定素数的算法，其时间复杂度为$O(logn)$Pollard-Rho是一种能够快速进行质因数分解的算法，其时间复杂度为$O(n^{1/4})$，空间复杂度为$O(logn)$。 算法介绍以下内容来自zbx大佬的PPT Miller-Rabin 偶数单独处理，否则设$n=2^t×m+1$;任选一个整数a，对$k=0,1,2,…,t$分别计算$a^{2^k*m}%n$的值$a(k)$;对于某个k，如果$a(k)=1$，但$a(k-1)$既不是1也不是n−1，则n是合数；如果$a(t)$仍然不是1，则n是合数；否则，n通过了基于a的测试，可以另选一个整数a继续测试。每一轮测试时间复杂度$O(logn)$，进行c轮时间复杂度$O(clogn)$。 $n\leq2^{32}$时，只需检测$a=2,7,61$，即可确保正确，即$c=3$；$n\leq2^{64}$时，只需检测$a=2,3,5,7,11$，即可确保正确，即$c=5$。n特别大时，随机选一个a进行测试，合数通过测试的概率低于$\frac{1}{4}$，合数通过c轮测试的概率低于$\frac{1}{4^c}$，适当设定测试次数即可。 Pollard-Rho 先用Miller-Rabin算法确定n是合数；随机整数$x_0$和a，生成一个序列$x_{i+1}=(x_i^2+a)%n$；对$i=1,2,3…$分别计算$p=gcd⁡(\mid x_{2i}−x_{i}\mid,n)$，当$x_{2i}=x_{i}$时停止并重新随机生成$x_0$和a；如果$p\not=1$则找到了n的一个约数p，递归处理p和n/p。时间复杂度$O(n^{1/4})$，空间复杂度$O(log⁡n)$。 时间复杂度的计算：设$n=pq,p\leq q$，序列$y_i \equiv x_i(mod p)$；根据生日悖论，${y_i}$周期期望长度$O(\sqrt p)$，${x_i}$周期期望长度$O(\sqrt n)$，不妨假设${y_i}$周期短；设${y_i}$周期为t，则$x_2t$与$x_t$还没进入周期，计算$gcd(\mid x_{2t}−x_t\mid, n)$可以得到p。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149class Miller_Rho&#123;public: vector&lt;ll&gt; res; //质因数分解结果 map&lt;ll, ll&gt; cnt; //统计每个因数的数目 Miller_Rho() &#123; vector&lt;ll&gt;().swap(res); map&lt;ll, ll&gt;().swap(cnt); &#125; ll fm(ll a, ll b, ll mod) &#123; ll res = 0; while(b) &#123; if(b&amp;1) res += a; b &gt;&gt;= 1; res %= mod; a += a; a %= mod; &#125; return res; &#125; ll fp(ll a, ll b, ll mod) &#123; a %= mod; ll res = 1; while(b) &#123; if(b&amp;1) res = fm(res, a, mod); b &gt;&gt;= 1; a = fm(a, a, mod); &#125; return res; &#125; // Miller-Rabin算法核心 bool check(ll a, ll n, ll x, ll t) &#123; ll res = fp(a, x, n); //即a ^ x % n; ll lst = res; for(int i = 0; i &lt; t; ++i) &#123; res *= res; res %= n; if(res == 1 &amp;&amp; lst != 1 &amp;&amp; lst != n-1) return false; lst = res; &#125; if(res != 1) return false; return true; &#125; bool is_prime(ll x) &#123; if(x &lt; 2) return false; if(x == 2) return true; if(x%2 == 0) return false; ll t = 0; // x = 2^t*m + 1 ll n = x-1; while(n%2 == 0) &#123; n &gt;&gt;= 1; t++; &#125; for(int i = 0; i &lt; 20; ++i) &#123; ll temp = rand()%(x-1)+1; if(!check(temp, x, n, t)) return false; &#125; return true; &#125; ll pollard_rho(ll x, ll c) &#123; ll i = 1, k = 2; ll x0 = rand() % x; ll y = x0; while(1) &#123; i++; x0 = (fm(x0, x0, x) + c) % x; //即(x0 * x0 + c) % x; ll gcd = abs(__gcd(y-x0, x)); if(gcd != 1 &amp;&amp; gcd != x) return gcd; if(y == x0) return x; if(i == k) &#123; y = x0; k += k; &#125; &#125; &#125; void get_fact(ll x) &#123; if(is_prime(x)) &#123; res.push_back(x); cnt[x]++; return ; &#125; ll p = x; while(p &gt;= x) p = pollard_rho(p, rand()%(x-1)+1); get_fact(p); get_fact(x/p); &#125; void init() &#123; srand(time(NULL)); vector&lt;ll&gt;().swap(res); map&lt;ll, ll&gt;().swap(cnt); &#125; void fact_sort() &#123; sort(res.begin(), res.end()); &#125; void fact_uniq() &#123; sort(res.begin(), res.end()); unique(res.begin(), res.end()); res.resize(cnt.size()); &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; os, Miller_Rho&amp; current) &#123; if(current.res.size()) os &lt;&lt; current.res[0]; for(unsigned int i = 1, t = current.res.size(); i &lt; t; ++i) os &lt;&lt; "*" &lt;&lt; current.res[i]; os &lt;&lt; endl; return os; &#125;&#125;; Tipsfm函数的作用是防止在进行乘法时爆long long]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[次小生成树]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[次小生成树，即把所有生成树按权值从小到大排列，排在第二位生成树。（如果最小生成树不唯一，次小生成树的权值和最小生成树相等） 算法介绍显然，次小生成树必然是经过最小生成树加一条边后删一条边得到的。 最容易想到的方法就是暴力。 由于次小生成树不会和最小生成树完全相同，所以我们求出最小生成树后，依次枚举不出现在次小生成树上的边，然后对n-1张“缺一条边的图”求一次最小生成树。这n-1棵树中权值最小的树即为次小生成树。 然而，暴力法的时间复杂度$O(mn\alpha(n, m))$是大部分情况下是无法接受的。 还有一种更好的方法：枚举要加入哪条新边。在最小生成树上添加一条新边$&lt;u, v&gt;$之后，图上会出现一条回路，因此删除的边必须在最小生成树上u到v的路径上，并且删去的边的权值必然是最大的。总时间复杂度为$O(n^2)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const vector&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const set&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;struct edge&#123; int f, t, c; bool vis; edge(int f = 0, int t = 0, int c = 0): f(f), t(t), c(c), vis(false)&#123;&#125; bool operator &lt; (const edge&amp; cmp) const &#123; if(c == cmp.c) &#123; if(f == cmp.f) return t &lt; cmp.t; return f &lt; cmp.f; &#125; return c &lt; cmp.c; &#125; void read() &#123; f = ::read&lt;int&gt;(); t = ::read&lt;int&gt;(); c = ::read&lt;int&gt;(); &#125;&#125;;const int M = 1e3 + 233;const int N = 1e6 + 666;const int INF = 1e9 + 7;edge a[N];int fa[M], n, m;vector&lt;int&gt; g[M];int maxd[M][M];int found(int x)&#123; return x == fa[x]? x: fa[x] = found(fa[x]);&#125;void kruskal()&#123; for(int i = 0; i &lt;= n; ++i) &#123; g[i].clear(); g[i].push_back(i); fa[i] = i; &#125; int sumn = 0, cnt = 0; for(int i = 0; i &lt; m; ++i) &#123; if(cnt == n-1) break; int x = found(a[i].f); int y = found(a[i].t); if(x != y) &#123; cnt++; a[i].vis = true; sumn += a[i].c; for(auto j: g[x]) for(auto k: g[y]) maxd[j][k] = maxd[k][j] = a[i].c; fa[x] = y; for(auto j: g[x]) g[y].push_back(j); &#125; &#125; if(cnt &lt; n-1) &#123; printf("No MST\n"); return ; &#125; int temp = INF; for(int i = 0; i &lt; m; ++i) if(!a[i].vis) temp = min(temp, sumn + a[i].c - maxd[a[i].f][a[i].t]); printf("%d\n", temp);&#125;// #define localint main()&#123;#ifdef local freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif n = read&lt;int&gt;(); m = read&lt;int&gt;(); for(int i = 0; i &lt; m; ++i) a[i].read(); sort(a, a+m); kruskal(); return 0;&#125; Tips这种方法也可以用于判定最小生成树的唯一性。（当次小生成树的权值与最小生成树相等时，最小生成树不唯一）]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay树]]></title>
    <url>%2F2019%2F03%2F28%2FSplay-Tree%2F</url>
    <content type="text"><![CDATA[伸展树（Splay Tree），也叫分裂树，是一种二叉排序树。平均情况下，它能在$O(log N)$ 极端情况下为O(N) 内完成插入、查找和删除操作。其优势在于不需要记录平衡树的冗余信息。 简介现要维护一个序列${A_n}$(所有$A_i$初值为0)，要求支持如下操作(bzoj1251)： 对于区间$[L, R]$上的每一个元素，其值增加$val$ 对于区间$[L, R]$翻转这段区间上的元素 查询区间$[L, R]$上的最大值 由于翻转操作的存在，导致使用线段树维护变的困难，所以这里使用splay进行维护。 对于每次操作，我们将下标为L-1的节点旋转至树根，将下标为R+1的节点旋转至树根的右儿子，由于splay树的有序性，区间[L, R]就是R+1的左子树。 旋转操作Zig(将x节点右旋至根节点，Zag操作反之): Zig-Zig(对x节点进行两次右旋操作，使其到达根节点): Zig-Zag(对x节点线进行左旋，在进行右旋操作，使其到达根节点): 需要注意的是，splay树永远满足如下性质： 对于任意节点（不妨设其下标为x)，设其左儿子（如有）的下标为L，其右儿子（如有）的下标为R，则有：$L &lt; x &lt; R$ 旋转操作永远不会改变这一性质(具体操作见代码中的rotate函数)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;assert.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;struct splay_tree&#123; static const int N = 1e5 + 233; static const int INF = 1e9 + 7; struct node &#123; int val, Max, add, sz, son[2]; bool rev; void init(int _val) &#123; val = Max = _val; add = rev = son[0] = son[1] = 0; sz = 1; &#125; &#125;; node T[N]; int fa[N], root; // 重新获取节点信息 void pushup(int x) &#123; T[x].Max = T[x].val; T[x].sz = 1; if(T[x].son[0]) &#123; T[x].Max = max(T[x].Max, T[T[x].son[0]].Max); T[x].sz += T[T[x].son[0]].sz; &#125; if(T[x].son[1]) &#123; T[x].Max = max(T[x].Max, T[T[x].son[1]].Max); T[x].sz += T[T[x].son[1]].sz; &#125; &#125; // 下放标记 void pushdown(int x) &#123; if(x == 0) return ; if(T[x].add) &#123; if(T[x].son[0]) &#123; T[T[x].son[0]].val += T[x].add; T[T[x].son[0]].add += T[x].add; T[T[x].son[0]].Max += T[x].add; &#125; if(T[x].son[1]) &#123; T[T[x].son[1]].val += T[x].add; T[T[x].son[1]].add += T[x].add; T[T[x].son[1]].Max += T[x].add; &#125; T[x].add = 0; &#125; if(T[x].rev) &#123; if(T[x].son[0]) T[T[x].son[0]].rev ^= 1; if(T[x].son[1]) T[T[x].son[1]].rev ^= 1; swap(T[x].son[0], T[x].son[1]); T[x].rev = 0; &#125; &#125; // kind = 0时左旋，kind = 1时右旋 void rotate(int x, int kind) &#123; int y = fa[x]; int z = fa[y]; T[y].son[!kind] = T[x].son[kind]; fa[T[x].son[kind]] = y; T[x].son[kind] = y; fa[y] = x; T[z].son[T[z].son[1] == y] = x; fa[x] = z; pushup(y); &#125; // 将节点x旋转至goal位置 void splay(int x, int goal) &#123; if(x == goal) return ; while(fa[x] != goal) &#123; int y = fa[x]; int z = fa[y]; pushdown(x); pushdown(y); pushdown(z); int rx = T[y].son[0] == x; int ry = T[z].son[0] == y; if(z == goal) rotate(x, rx); else &#123; if(rx == ry) rotate(y, ry); else rotate(x, rx); rotate(x, ry); &#125; &#125; pushup(x); if(goal == 0) root = x; &#125; // 返回下标为pos的节点在树的位置 int select(int pos) &#123; int u = root; pushdown(u); while(T[T[u].son[0]].sz != pos) &#123; if(pos &lt; T[T[u].son[0]].sz) u = T[u].son[0]; else &#123; pos -= T[T[u].son[0]].sz + 1; u = T[u].son[1]; &#125; pushdown(u); &#125; return u; &#125; // 查询、修改操作相关 int pre_sol(int l, int r) &#123; int u = select(l-1); int v = select(r+1); splay(u, 0); splay(v, u); return v; &#125; void update(int l, int r, int val) &#123; int v = pre_sol(l, r); T[T[v].son[0]].Max += val; T[T[v].son[0]].val += val; T[T[v].son[0]].add += val; &#125; void reverse(int l, int r) &#123; int v = pre_sol(l, r); T[T[v].son[0]].rev ^= 1; &#125; int query(int l, int r) &#123; int v = pre_sol(l, r); return T[T[v].son[0]].Max; &#125; int build(int l, int r) &#123; if(l &gt; r) return 0; if(l == r) return l; int mid = (l+r) &gt;&gt; 1, sl, sr; T[mid].son[0] = sl = build(l, mid-1); T[mid].son[1] = sr = build(mid+1, r); fa[sl] = fa[sr] = mid; pushup(mid); return mid; &#125; // 预处理，注意三个-INF的边界处理 void init(int n) &#123; T[0].init(-INF); T[1].init(-INF); T[n+2].init(-INF); for(int i = 2; i &lt;= n+1; ++i) T[i].init(0); root = build(1, n+2); fa[root] = 0; fa[0] = 0; T[0].son[1] = root; T[0].sz = 0; &#125;&#125;;splay_tree solver;// #define localint main()&#123;#ifdef local freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif int n = read&lt;int&gt;(); int m = read&lt;int&gt;(); solver.init(n); for(int i = 0; i &lt; m; ++i) &#123; int a, b, c, d; a = read&lt;int&gt;(); b = read&lt;int&gt;(); c = read&lt;int&gt;(); if(a == 1) &#123; d = read&lt;int&gt;(); solver.update(b, c, d); &#125; else if(a == 2) solver.reverse(b, c); else printf("%d\n", solver.query(b, c)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>区间维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManaCher算法]]></title>
    <url>%2F2019%2F03%2F25%2FManaCher%2F</url>
    <content type="text"><![CDATA[Manacher算法是查找一个字符串的最长回文子串的线性算法。其时间复杂度为$O(n)$ 算法介绍由于存在奇回文与偶回文两种类型的回文串，分开判断较为复杂，所以将二者全部处理成奇回文。(以下内容来自Sundes大佬的PPT) 考虑将原字符串StrA进行预处理，不妨在字符串首尾位置以及任意两字符之间插入一个原本不存在于StrA中的字符。得到字符串StrB，经过这样处理后所有的回文都变成了奇回文，且回文性质不变。如:$$bob –&gt; #b#o#b#$$$$noon –&gt; #n#o#o#n#$$$$level –&gt; #l#e#v#e#l#$$由于第一个和最后一个字符都是#号，且也需要搜索回文，为了防止越界，我们还需要在首尾再加上非#号字符，实际操作时我们只需给开头加上个非#号字符，结尾不用加的原因是字符串的结尾标识为’\0’，等于默认加过了。不妨在字符串首插入字符’\$’$$bob –&gt; $#b#o#b#$$$$noon –&gt; $#n#o#o#n#$$$$level –&gt; $#l#e#v#e#l#$$通过以上预处理，字符串StrA转化为了字符串StrB。 记数组p[max_len]，p[i]表示StrB以i位置的字符为中心点，最长回文子串的半径大小 (即回文长度(len-1)/2) ，注意max_len最少应为原字符串StrA长度两倍加一。通过p数组我们就可以找到其最大值和其位置，就能确定最长回文子串了，那么下面我们就来看如何求p数组，需要新增两个辅助变量mx和id，其中id为最大回文子串中心的位置，mx是回文串能延伸到的最右端的位置。(即id+p[id])这个算法的最核心的一行如下：$$p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;$$ 下面详细介绍该转移方程的内涵当 mx - i &gt; p[j] 的时候，以StrB[j]为中心的回文子串包含在以StrB[id]为中心的回文子串中，由于 i 和 j 对称，以StrB[i]为中心的回文子串必然包含在以StrB[id]为中心的回文子串中，所以必有 $P[i] = P[j]$，见下图。 当 $P[j] &gt;= mx - i$ 的时候，以StrB[j]为中心的回文子串不完全包含于以StrB[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以StrB[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 $P[i] &gt;= mx - i$。至于mx之后的部分是否依旧对称，则需要朴素的对比。在此过程中维护mx与id。（若回文串能延伸到的最右端的位置大于mx，则修改mx与id） 对于 $mx &lt;= i$ 的情况，无法对 P[i]做更多的假设，只能$P[i] = 1$，然后再去匹配了。由于每一个位置最多只会被朴素的匹配一次，所以算法复杂程度$O(n)$; 代码12345678910111213141516171819202122int manacher()&#123; int len = strlen(s); int maxr = 0, mid = 0; for(int i = 1; i &lt; len; ++i) &#123; if(i &lt; maxr) val[i] = min(val[(mid&lt;&lt;1) - i], maxr-i); else val[i] = 1; while(s[i-val[i]] == s[i+val[i]]) val[i]++; if(val[i] + i &gt; maxr) &#123; maxr = val[i] + i; mid = i; &#125; printf("%d ", val[i]); &#125; return (*max_element(val, val+len)) - 1;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老司机树]]></title>
    <url>%2F2019%2F03%2F24%2FODT%2F</url>
    <content type="text"><![CDATA[老司机树(ODT，又名Chtholly Tree，珂朵莉树), 由ODT大佬提出。 简介来源：Codeforces896C对于一个序列，随机地进行一系列包含推平一段区间在内的操作，可以采用这种数据结构 其核心思想为，将每一段值相等的子序列用一个三元组$(l, r, val)$表示，由于“推平一段区间”操作的存在且操作是随机的，所以三元组序列的长度将趋近于$log n$。 对于每次操作$[L, R]$，将包含待L或R的三元组$(x, y, val)$分成两个三元组$(x, L-1, val)$, $(L, y, val)$, 使得$L, R$处于三元组的左边界，然后对区间内部的三元组进行暴力维护。 顺带提一句，如果使用set维护三元组的话，由于set内部的元素一旦插入就不可更改，所以成员变量应当使用mutable关键字声明。 注意如果值的更改使得元素的优先级发生了变化，将导致set内部元素不再有序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const vector&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const set&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;class node&#123; public: mutable ll l, r, val; node(ll l = 0, ll r = 0, ll val = 0): l(l), r(r), val(val)&#123;&#125; bool operator &lt; (const node&amp; cmp) const &#123; if(l == cmp.l) return r &lt; cmp.r; return l &lt; cmp.l; &#125; &#125;;class heapnode&#123; public: ll len, val; heapnode(ll len = 0, ll val = 0): len(len), val(val)&#123;&#125; bool operator &lt; (const heapnode&amp; cmp) const &#123; if(val == cmp.val) return len &lt; cmp.len; return val &lt; cmp.val; &#125;&#125;;const ll MOD = 1e9 + 7;const int N = 1e5 + 233;ll dig[N], seed, n, m, op, vm, l, r, x, y;set&lt;node&gt; s;vector&lt;heapnode&gt; v;ll rnd()&#123; ll ret = seed; seed = (seed * 7 + 13) % MOD; return ret;&#125;void getData()&#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;seed, &amp;vm); for(int i = 1; i &lt;= n; ++i) dig[i] = (rnd() % vm) + 1;&#125;void getOp()&#123; op = (rnd() % 4) + 1; l = (rnd() % n) + 1; r = (rnd() % n) + 1; x = y = 0; if(l &gt; r) swap(l, r); if(op == 3) x = (rnd() % (r-l+1)) + 1; else x = (rnd() % vm) + 1; if(op == 4) y = (rnd() % vm) + 1; &#125;set&lt;node&gt;::iterator split(int pos)&#123; auto p = s.lower_bound(node(pos)); if(p != s.end() &amp;&amp; p-&gt;l == pos) return p; p--; if(pos &gt; p-&gt;r) return s.end(); ll l = p-&gt;l; ll r = p-&gt;r; ll v = p-&gt;val; s.erase(p); s.emplace(l, pos-1, v); return s.emplace(pos, r, v).first;&#125;ll fp(ll x, ll y, ll mod)&#123; ll res = 1; x %= mod; while(y) &#123; if(y&amp;1) res *= x; x *= x; x %= mod; res %= mod; y &gt;&gt;= 1; &#125; return res;&#125;// #define localint main()&#123;#ifdef local freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif getData(); for(int i = 1; i &lt;= n; ++i) s.emplace(i, i, dig[i]); while(m--) &#123; getOp(); split(l); auto sr = split(r+1); auto sl = split(l); switch(op) &#123; case 1: &#123; for(; sl != sr; ++sl) sl-&gt;val += x; break; &#125; case 2: &#123; s.erase(sl, sr); s.emplace(l, r, x); break; &#125; case 3: &#123; vector&lt;heapnode&gt;().swap(v); bool ok = false; for(; sl != sr; ++sl) v.emplace_back(sl-&gt;r - sl-&gt;l + 1, sl-&gt;val); sort(v.begin(), v.end()); for(auto i: v) &#123; x -= i.len; if(x &lt;= 0) &#123; printf("%I64d\n", i.val); ok = true; break; &#125; &#125; assert(ok); break; &#125; case 4: &#123; ll res = 0; while(sl != sr) &#123; ll temp = (sl-&gt;r - sl-&gt;l + 1) * fp(sl-&gt;val, x, y); temp %= y; res += temp; res %= y; sl++; &#125; printf("%I64d\n", res); break; &#125; default: assert(false); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>区间维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
