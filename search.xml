<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Miller-Rabin & Pollard-Rho]]></title>
    <url>%2F2019%2F04%2F04%2FMiller-Rabin%26Pollard-Rho%2F</url>
    <content type="text"><![CDATA[Miller-Rabinæ˜¯ä¸€ç§èƒ½å¤Ÿå¿«é€Ÿåˆ¤å®šç´ æ•°çš„ç®—æ³•ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¸º$O(logn)$Pollard-Rhoæ˜¯ä¸€ç§èƒ½å¤Ÿå¿«é€Ÿè¿›è¡Œè´¨å› æ•°åˆ†è§£çš„ç®—æ³•ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¸º$O(n^1/4)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º$O(logn)$ã€‚ ç®—æ³•ä»‹ç»ä»¥ä¸‹å†…å®¹æ¥è‡ªzbxå¤§ä½¬çš„PPT Miller-Rabin å¶æ•°å•ç‹¬å¤„ç†ï¼Œå¦åˆ™è®¾$n=2^tÃ—m+1$;ä»»é€‰ä¸€ä¸ªæ•´æ•°aï¼Œå¯¹$k=0,1,2,â€¦,t$åˆ†åˆ«è®¡ç®—$a^(2^k*m)%n$çš„å€¼$a(k)$;å¯¹äºæŸä¸ªkï¼Œå¦‚æœ$a(k)=1$ï¼Œä½†$a(k-1)$æ—¢ä¸æ˜¯1ä¹Ÿä¸æ˜¯nâˆ’1ï¼Œåˆ™næ˜¯åˆæ•°ï¼›å¦‚æœ$a(t)$ä»ç„¶ä¸æ˜¯1ï¼Œåˆ™næ˜¯åˆæ•°ï¼›å¦åˆ™ï¼Œné€šè¿‡äº†åŸºäºaçš„æµ‹è¯•ï¼Œå¯ä»¥å¦é€‰ä¸€ä¸ªæ•´æ•°aç»§ç»­æµ‹è¯•ã€‚æ¯ä¸€è½®æµ‹è¯•æ—¶é—´å¤æ‚åº¦$O(logn)$ï¼Œè¿›è¡Œcè½®æ—¶é—´å¤æ‚åº¦$O(clogn)$ã€‚ Pollard-Rho å…ˆç”¨Miller-Rabinç®—æ³•ç¡®å®šnæ˜¯åˆæ•°ï¼›éšæœºæ•´æ•°$x_0$å’Œaï¼Œç”Ÿæˆä¸€ä¸ªåºåˆ—$x[i+1]=(x[i]^2+a)%n$ï¼›å¯¹$i=1,2,3â€¦$åˆ†åˆ«è®¡ç®—$p=gcdâ¡(abs(x[2i]âˆ’x[i]), n)$ï¼Œå½“$x[2i]=x[i]$æ—¶åœæ­¢å¹¶é‡æ–°éšæœºç”Ÿæˆx0å’Œaï¼›å¦‚æœ$p\not=1$åˆ™æ‰¾åˆ°äº†nçš„ä¸€ä¸ªçº¦æ•°pï¼Œé€’å½’å¤„ç†på’Œn/pã€‚æ—¶é—´å¤æ‚åº¦$O(n^(1/4))$ï¼Œç©ºé—´å¤æ‚åº¦$O(logâ¡n)$ã€‚ æ—¶é—´å¤æ‚åº¦çš„è®¡ç®—ï¼šè®¾$n=pq,p\leqq$ï¼Œåºåˆ—$y_i=x_i(\equivp)$ï¼›æ ¹æ®ç”Ÿæ—¥æ‚–è®ºï¼Œ{ğ‘¦ğ‘– }å‘¨æœŸæœŸæœ›é•¿åº¦ğ‘‚(âˆšğ‘)ï¼Œ{ğ‘¥ğ‘– }å‘¨æœŸæœŸæœ›é•¿åº¦ğ‘‚(âˆšğ‘›)ï¼Œä¸å¦¨å‡è®¾{ğ‘¦ğ‘– }å‘¨æœŸçŸ­ï¼›è®¾{ğ‘¦ğ‘– }å‘¨æœŸä¸ºğ‘¡ï¼Œåˆ™ğ‘¥2ğ‘¡ä¸ğ‘¥ğ‘¡è¿˜æ²¡è¿›å…¥å‘¨æœŸï¼Œè®¡ç®—gcd(|ğ‘¥2ğ‘¡âˆ’ğ‘¥ğ‘¡ |,ğ‘›)å¯ä»¥å¾—åˆ°ğ‘ã€‚]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ•°è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¬¡å°ç”Ÿæˆæ ‘]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[æ¬¡å°ç”Ÿæˆæ ‘ï¼Œå³æŠŠæ‰€æœ‰ç”Ÿæˆæ ‘æŒ‰æƒå€¼ä»å°åˆ°å¤§æ’åˆ—ï¼Œæ’åœ¨ç¬¬äºŒä½ç”Ÿæˆæ ‘ã€‚ï¼ˆå¦‚æœæœ€å°ç”Ÿæˆæ ‘ä¸å”¯ä¸€ï¼Œæ¬¡å°ç”Ÿæˆæ ‘çš„æƒå€¼å’Œæœ€å°ç”Ÿæˆæ ‘ç›¸ç­‰ï¼‰ ç®—æ³•ä»‹ç»æ˜¾ç„¶ï¼Œæ¬¡å°ç”Ÿæˆæ ‘å¿…ç„¶æ˜¯ç»è¿‡æœ€å°ç”Ÿæˆæ ‘åŠ ä¸€æ¡è¾¹ååˆ ä¸€æ¡è¾¹å¾—åˆ°çš„ã€‚ æœ€å®¹æ˜“æƒ³åˆ°çš„æ–¹æ³•å°±æ˜¯æš´åŠ›ã€‚ ç”±äºæ¬¡å°ç”Ÿæˆæ ‘ä¸ä¼šå’Œæœ€å°ç”Ÿæˆæ ‘å®Œå…¨ç›¸åŒï¼Œæ‰€ä»¥æˆ‘ä»¬æ±‚å‡ºæœ€å°ç”Ÿæˆæ ‘åï¼Œä¾æ¬¡æšä¸¾ä¸å‡ºç°åœ¨æ¬¡å°ç”Ÿæˆæ ‘ä¸Šçš„è¾¹ï¼Œç„¶åå¯¹n-1å¼ â€œç¼ºä¸€æ¡è¾¹çš„å›¾â€æ±‚ä¸€æ¬¡æœ€å°ç”Ÿæˆæ ‘ã€‚è¿™n-1æ£µæ ‘ä¸­æƒå€¼æœ€å°çš„æ ‘å³ä¸ºæ¬¡å°ç”Ÿæˆæ ‘ã€‚ ç„¶è€Œï¼Œæš´åŠ›æ³•çš„æ—¶é—´å¤æ‚åº¦$O(mn\alpha(n, m))$æ˜¯å¤§éƒ¨åˆ†æƒ…å†µä¸‹æ˜¯æ— æ³•æ¥å—çš„ã€‚ è¿˜æœ‰ä¸€ç§æ›´å¥½çš„æ–¹æ³•ï¼šæšä¸¾è¦åŠ å…¥å“ªæ¡æ–°è¾¹ã€‚åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸Šæ·»åŠ ä¸€æ¡æ–°è¾¹$&lt;u, v&gt;$ä¹‹åï¼Œå›¾ä¸Šä¼šå‡ºç°ä¸€æ¡å›è·¯ï¼Œå› æ­¤åˆ é™¤çš„è¾¹å¿…é¡»åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸Šuåˆ°vçš„è·¯å¾„ä¸Šï¼Œå¹¶ä¸”åˆ å»çš„è¾¹çš„æƒå€¼å¿…ç„¶æ˜¯æœ€å¤§çš„ã€‚æ€»æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const vector&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const set&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;struct edge&#123; int f, t, c; bool vis; edge(int f = 0, int t = 0, int c = 0): f(f), t(t), c(c), vis(false)&#123;&#125; bool operator &lt; (const edge&amp; cmp) const &#123; if(c == cmp.c) &#123; if(f == cmp.f) return t &lt; cmp.t; return f &lt; cmp.f; &#125; return c &lt; cmp.c; &#125; void read() &#123; f = ::read&lt;int&gt;(); t = ::read&lt;int&gt;(); c = ::read&lt;int&gt;(); &#125;&#125;;const int M = 1e3 + 233;const int N = 1e6 + 666;const int INF = 1e9 + 7;edge a[N];int fa[M], n, m;vector&lt;int&gt; g[M];int maxd[M][M];int found(int x)&#123; return x == fa[x]? x: fa[x] = found(fa[x]);&#125;void kruskal()&#123; for(int i = 0; i &lt;= n; ++i) &#123; g[i].clear(); g[i].push_back(i); fa[i] = i; &#125; int sumn = 0, cnt = 0; for(int i = 0; i &lt; m; ++i) &#123; if(cnt == n-1) break; int x = found(a[i].f); int y = found(a[i].t); if(x != y) &#123; cnt++; a[i].vis = true; sumn += a[i].c; for(auto j: g[x]) for(auto k: g[y]) maxd[j][k] = maxd[k][j] = a[i].c; fa[x] = y; for(auto j: g[x]) g[y].push_back(j); &#125; &#125; if(cnt &lt; n-1) &#123; printf("No MST\n"); return ; &#125; int temp = INF; for(int i = 0; i &lt; m; ++i) if(!a[i].vis) temp = min(temp, sumn + a[i].c - maxd[a[i].f][a[i].t]); printf("%d\n", temp);&#125;// #define localint main()&#123;#ifdef local freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif n = read&lt;int&gt;(); m = read&lt;int&gt;(); for(int i = 0; i &lt; m; ++i) a[i].read(); sort(a, a+m); kruskal(); return 0;&#125; Tipsè¿™ç§æ–¹æ³•ä¹Ÿå¯ä»¥ç”¨äºåˆ¤å®šæœ€å°ç”Ÿæˆæ ‘çš„å”¯ä¸€æ€§ã€‚ï¼ˆå½“æ¬¡å°ç”Ÿæˆæ ‘çš„æƒå€¼ä¸æœ€å°ç”Ÿæˆæ ‘ç›¸ç­‰æ—¶ï¼Œæœ€å°ç”Ÿæˆæ ‘ä¸å”¯ä¸€ï¼‰]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ç”Ÿæˆæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splayæ ‘]]></title>
    <url>%2F2019%2F03%2F28%2FSplay-Tree%2F</url>
    <content type="text"><![CDATA[ä¼¸å±•æ ‘ï¼ˆSplay Treeï¼‰ï¼Œä¹Ÿå«åˆ†è£‚æ ‘ï¼Œæ˜¯ä¸€ç§äºŒå‰æ’åºæ ‘ã€‚å¹³å‡æƒ…å†µä¸‹ï¼Œå®ƒèƒ½åœ¨$O(log N)$ æç«¯æƒ…å†µä¸‹ä¸ºO(N) å†…å®Œæˆæ’å…¥ã€æŸ¥æ‰¾å’Œåˆ é™¤æ“ä½œã€‚å…¶ä¼˜åŠ¿åœ¨äºä¸éœ€è¦è®°å½•å¹³è¡¡æ ‘çš„å†—ä½™ä¿¡æ¯ã€‚ ç®€ä»‹ç°è¦ç»´æŠ¤ä¸€ä¸ªåºåˆ—${A_n}$(æ‰€æœ‰$A_i$åˆå€¼ä¸º0)ï¼Œè¦æ±‚æ”¯æŒå¦‚ä¸‹æ“ä½œ(bzoj1251)ï¼š å¯¹äºåŒºé—´$[L, R]$ä¸Šçš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå…¶å€¼å¢åŠ $val$ å¯¹äºåŒºé—´$[L, R]$ç¿»è½¬è¿™æ®µåŒºé—´ä¸Šçš„å…ƒç´  æŸ¥è¯¢åŒºé—´$[L, R]$ä¸Šçš„æœ€å¤§å€¼ ç”±äºç¿»è½¬æ“ä½œçš„å­˜åœ¨ï¼Œå¯¼è‡´ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤å˜çš„å›°éš¾ï¼Œæ‰€ä»¥è¿™é‡Œä½¿ç”¨splayè¿›è¡Œç»´æŠ¤ã€‚ å¯¹äºæ¯æ¬¡æ“ä½œï¼Œæˆ‘ä»¬å°†ä¸‹æ ‡ä¸ºL-1çš„èŠ‚ç‚¹æ—‹è½¬è‡³æ ‘æ ¹ï¼Œå°†ä¸‹æ ‡ä¸ºR+1çš„èŠ‚ç‚¹æ—‹è½¬è‡³æ ‘æ ¹çš„å³å„¿å­ï¼Œç”±äºsplayæ ‘çš„æœ‰åºæ€§ï¼ŒåŒºé—´[L, R]å°±æ˜¯R+1çš„å·¦å­æ ‘ã€‚ æ—‹è½¬æ“ä½œZig(å°†xèŠ‚ç‚¹å³æ—‹è‡³æ ¹èŠ‚ç‚¹ï¼ŒZagæ“ä½œåä¹‹): Zig-Zig(å¯¹xèŠ‚ç‚¹è¿›è¡Œä¸¤æ¬¡å³æ—‹æ“ä½œï¼Œä½¿å…¶åˆ°è¾¾æ ¹èŠ‚ç‚¹): Zig-Zag(å¯¹xèŠ‚ç‚¹çº¿è¿›è¡Œå·¦æ—‹ï¼Œåœ¨è¿›è¡Œå³æ—‹æ“ä½œï¼Œä½¿å…¶åˆ°è¾¾æ ¹èŠ‚ç‚¹): éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œsplayæ ‘æ°¸è¿œæ»¡è¶³å¦‚ä¸‹æ€§è´¨ï¼š å¯¹äºä»»æ„èŠ‚ç‚¹ï¼ˆä¸å¦¨è®¾å…¶ä¸‹æ ‡ä¸ºx)ï¼Œè®¾å…¶å·¦å„¿å­ï¼ˆå¦‚æœ‰ï¼‰çš„ä¸‹æ ‡ä¸ºLï¼Œå…¶å³å„¿å­ï¼ˆå¦‚æœ‰ï¼‰çš„ä¸‹æ ‡ä¸ºRï¼Œåˆ™æœ‰ï¼š$L &lt; x &lt; R$ æ—‹è½¬æ“ä½œæ°¸è¿œä¸ä¼šæ”¹å˜è¿™ä¸€æ€§è´¨(å…·ä½“æ“ä½œè§ä»£ç ä¸­çš„rotateå‡½æ•°)ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;assert.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;struct splay_tree&#123; static const int N = 1e5 + 233; static const int INF = 1e9 + 7; struct node &#123; int val, Max, add, sz, son[2]; bool rev; void init(int _val) &#123; val = Max = _val; add = rev = son[0] = son[1] = 0; sz = 1; &#125; &#125;; node T[N]; int fa[N], root; // é‡æ–°è·å–èŠ‚ç‚¹ä¿¡æ¯ void pushup(int x) &#123; T[x].Max = T[x].val; T[x].sz = 1; if(T[x].son[0]) &#123; T[x].Max = max(T[x].Max, T[T[x].son[0]].Max); T[x].sz += T[T[x].son[0]].sz; &#125; if(T[x].son[1]) &#123; T[x].Max = max(T[x].Max, T[T[x].son[1]].Max); T[x].sz += T[T[x].son[1]].sz; &#125; &#125; // ä¸‹æ”¾æ ‡è®° void pushdown(int x) &#123; if(x == 0) return ; if(T[x].add) &#123; if(T[x].son[0]) &#123; T[T[x].son[0]].val += T[x].add; T[T[x].son[0]].add += T[x].add; T[T[x].son[0]].Max += T[x].add; &#125; if(T[x].son[1]) &#123; T[T[x].son[1]].val += T[x].add; T[T[x].son[1]].add += T[x].add; T[T[x].son[1]].Max += T[x].add; &#125; T[x].add = 0; &#125; if(T[x].rev) &#123; if(T[x].son[0]) T[T[x].son[0]].rev ^= 1; if(T[x].son[1]) T[T[x].son[1]].rev ^= 1; swap(T[x].son[0], T[x].son[1]); T[x].rev = 0; &#125; &#125; // kind = 0æ—¶å·¦æ—‹ï¼Œkind = 1æ—¶å³æ—‹ void rotate(int x, int kind) &#123; int y = fa[x]; int z = fa[y]; T[y].son[!kind] = T[x].son[kind]; fa[T[x].son[kind]] = y; T[x].son[kind] = y; fa[y] = x; T[z].son[T[z].son[1] == y] = x; fa[x] = z; pushup(y); &#125; // å°†èŠ‚ç‚¹xæ—‹è½¬è‡³goalä½ç½® void splay(int x, int goal) &#123; if(x == goal) return ; while(fa[x] != goal) &#123; int y = fa[x]; int z = fa[y]; pushdown(x); pushdown(y); pushdown(z); int rx = T[y].son[0] == x; int ry = T[z].son[0] == y; if(z == goal) rotate(x, rx); else &#123; if(rx == ry) rotate(y, ry); else rotate(x, rx); rotate(x, ry); &#125; &#125; pushup(x); if(goal == 0) root = x; &#125; // è¿”å›ä¸‹æ ‡ä¸ºposçš„èŠ‚ç‚¹åœ¨æ ‘çš„ä½ç½® int select(int pos) &#123; int u = root; pushdown(u); while(T[T[u].son[0]].sz != pos) &#123; if(pos &lt; T[T[u].son[0]].sz) u = T[u].son[0]; else &#123; pos -= T[T[u].son[0]].sz + 1; u = T[u].son[1]; &#125; pushdown(u); &#125; return u; &#125; // æŸ¥è¯¢ã€ä¿®æ”¹æ“ä½œç›¸å…³ int pre_sol(int l, int r) &#123; int u = select(l-1); int v = select(r+1); splay(u, 0); splay(v, u); return v; &#125; void update(int l, int r, int val) &#123; int v = pre_sol(l, r); T[T[v].son[0]].Max += val; T[T[v].son[0]].val += val; T[T[v].son[0]].add += val; &#125; void reverse(int l, int r) &#123; int v = pre_sol(l, r); T[T[v].son[0]].rev ^= 1; &#125; int query(int l, int r) &#123; int v = pre_sol(l, r); return T[T[v].son[0]].Max; &#125; int build(int l, int r) &#123; if(l &gt; r) return 0; if(l == r) return l; int mid = (l+r) &gt;&gt; 1, sl, sr; T[mid].son[0] = sl = build(l, mid-1); T[mid].son[1] = sr = build(mid+1, r); fa[sl] = fa[sr] = mid; pushup(mid); return mid; &#125; // é¢„å¤„ç†ï¼Œæ³¨æ„ä¸‰ä¸ª-INFçš„è¾¹ç•Œå¤„ç† void init(int n) &#123; T[0].init(-INF); T[1].init(-INF); T[n+2].init(-INF); for(int i = 2; i &lt;= n+1; ++i) T[i].init(0); root = build(1, n+2); fa[root] = 0; fa[0] = 0; T[0].son[1] = root; T[0].sz = 0; &#125;&#125;;splay_tree solver;// #define localint main()&#123;#ifdef local freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif int n = read&lt;int&gt;(); int m = read&lt;int&gt;(); solver.init(n); for(int i = 0; i &lt; m; ++i) &#123; int a, b, c, d; a = read&lt;int&gt;(); b = read&lt;int&gt;(); c = read&lt;int&gt;(); if(a == 1) &#123; d = read&lt;int&gt;(); solver.update(b, c, d); &#125; else if(a == 2) solver.reverse(b, c); else printf("%d\n", solver.query(b, c)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>åŒºé—´ç»´æŠ¤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManaCherç®—æ³•]]></title>
    <url>%2F2019%2F03%2F25%2FManaCher%2F</url>
    <content type="text"><![CDATA[Manacherç®—æ³•æ˜¯æŸ¥æ‰¾ä¸€ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å›æ–‡å­ä¸²çš„çº¿æ€§ç®—æ³•ã€‚å…¶æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$ ç®—æ³•ä»‹ç»ç”±äºå­˜åœ¨å¥‡å›æ–‡ä¸å¶å›æ–‡ä¸¤ç§ç±»å‹çš„å›æ–‡ä¸²ï¼Œåˆ†å¼€åˆ¤æ–­è¾ƒä¸ºå¤æ‚ï¼Œæ‰€ä»¥å°†äºŒè€…å…¨éƒ¨å¤„ç†æˆå¥‡å›æ–‡ã€‚(ä»¥ä¸‹å†…å®¹æ¥è‡ªSundeså¤§ä½¬çš„PPT) è€ƒè™‘å°†åŸå­—ç¬¦ä¸²StrAè¿›è¡Œé¢„å¤„ç†ï¼Œä¸å¦¨åœ¨å­—ç¬¦ä¸²é¦–å°¾ä½ç½®ä»¥åŠä»»æ„ä¸¤å­—ç¬¦ä¹‹é—´æ’å…¥ä¸€ä¸ªåŸæœ¬ä¸å­˜åœ¨äºStrAä¸­çš„å­—ç¬¦ã€‚å¾—åˆ°å­—ç¬¦ä¸²StrBï¼Œç»è¿‡è¿™æ ·å¤„ç†åæ‰€æœ‰çš„å›æ–‡éƒ½å˜æˆäº†å¥‡å›æ–‡ï¼Œä¸”å›æ–‡æ€§è´¨ä¸å˜ã€‚å¦‚:$$bob â€“&gt; #b#o#b#$$$$noon â€“&gt; #n#o#o#n#$$$$level â€“&gt; #l#e#v#e#l#$$ç”±äºç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå­—ç¬¦éƒ½æ˜¯#å·ï¼Œä¸”ä¹Ÿéœ€è¦æœç´¢å›æ–‡ï¼Œä¸ºäº†é˜²æ­¢è¶Šç•Œï¼Œæˆ‘ä»¬è¿˜éœ€è¦åœ¨é¦–å°¾å†åŠ ä¸Šé#å·å­—ç¬¦ï¼Œå®é™…æ“ä½œæ—¶æˆ‘ä»¬åªéœ€ç»™å¼€å¤´åŠ ä¸Šä¸ªé#å·å­—ç¬¦ï¼Œç»“å°¾ä¸ç”¨åŠ çš„åŸå› æ˜¯å­—ç¬¦ä¸²çš„ç»“å°¾æ ‡è¯†ä¸ºâ€™\0â€™ï¼Œç­‰äºé»˜è®¤åŠ è¿‡äº†ã€‚ä¸å¦¨åœ¨å­—ç¬¦ä¸²é¦–æ’å…¥å­—ç¬¦â€™\$â€™$$bob â€“&gt; $#b#o#b#$$$$noon â€“&gt; $#n#o#o#n#$$$$level â€“&gt; $#l#e#v#e#l#$$é€šè¿‡ä»¥ä¸Šé¢„å¤„ç†ï¼Œå­—ç¬¦ä¸²StrAè½¬åŒ–ä¸ºäº†å­—ç¬¦ä¸²StrBã€‚ è®°æ•°ç»„p[max_len]ï¼Œp[i]è¡¨ç¤ºStrBä»¥iä½ç½®çš„å­—ç¬¦ä¸ºä¸­å¿ƒç‚¹ï¼Œæœ€é•¿å›æ–‡å­ä¸²çš„åŠå¾„å¤§å° (å³å›æ–‡é•¿åº¦(len-1)/2) ï¼Œæ³¨æ„max_lenæœ€å°‘åº”ä¸ºåŸå­—ç¬¦ä¸²StrAé•¿åº¦ä¸¤å€åŠ ä¸€ã€‚é€šè¿‡pæ•°ç»„æˆ‘ä»¬å°±å¯ä»¥æ‰¾åˆ°å…¶æœ€å¤§å€¼å’Œå…¶ä½ç½®ï¼Œå°±èƒ½ç¡®å®šæœ€é•¿å›æ–‡å­ä¸²äº†ï¼Œé‚£ä¹ˆä¸‹é¢æˆ‘ä»¬å°±æ¥çœ‹å¦‚ä½•æ±‚pæ•°ç»„ï¼Œéœ€è¦æ–°å¢ä¸¤ä¸ªè¾…åŠ©å˜é‡mxå’Œidï¼Œå…¶ä¸­idä¸ºæœ€å¤§å›æ–‡å­ä¸²ä¸­å¿ƒçš„ä½ç½®ï¼Œmxæ˜¯å›æ–‡ä¸²èƒ½å»¶ä¼¸åˆ°çš„æœ€å³ç«¯çš„ä½ç½®ã€‚(å³id+p[id])è¿™ä¸ªç®—æ³•çš„æœ€æ ¸å¿ƒçš„ä¸€è¡Œå¦‚ä¸‹ï¼š$$p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;$$ ä¸‹é¢è¯¦ç»†ä»‹ç»è¯¥è½¬ç§»æ–¹ç¨‹çš„å†…æ¶µå½“ mx - i &gt; p[j] çš„æ—¶å€™ï¼Œä»¥StrB[j]ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²åŒ…å«åœ¨ä»¥StrB[id]ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²ä¸­ï¼Œç”±äº i å’Œ j å¯¹ç§°ï¼Œä»¥StrB[i]ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²å¿…ç„¶åŒ…å«åœ¨ä»¥StrB[id]ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²ä¸­ï¼Œæ‰€ä»¥å¿…æœ‰ $P[i] = P[j]$ï¼Œè§ä¸‹å›¾ã€‚ å½“ $P[j] &gt;= mx - i$ çš„æ—¶å€™ï¼Œä»¥StrB[j]ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²ä¸å®Œå…¨åŒ…å«äºä»¥StrB[id]ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²ä¸­ï¼Œä½†æ˜¯åŸºäºå¯¹ç§°æ€§å¯çŸ¥ï¼Œä¸‹å›¾ä¸­ä¸¤ä¸ªç»¿æ¡†æ‰€åŒ…å›´çš„éƒ¨åˆ†æ˜¯ç›¸åŒçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ä»¥StrB[i]ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²ï¼Œå…¶å‘å³è‡³å°‘ä¼šæ‰©å¼ åˆ°mxçš„ä½ç½®ï¼Œä¹Ÿå°±æ˜¯è¯´ $P[i] &gt;= mx - i$ã€‚è‡³äºmxä¹‹åçš„éƒ¨åˆ†æ˜¯å¦ä¾æ—§å¯¹ç§°ï¼Œåˆ™éœ€è¦æœ´ç´ çš„å¯¹æ¯”ã€‚åœ¨æ­¤è¿‡ç¨‹ä¸­ç»´æŠ¤mxä¸idã€‚ï¼ˆè‹¥å›æ–‡ä¸²èƒ½å»¶ä¼¸åˆ°çš„æœ€å³ç«¯çš„ä½ç½®å¤§äºmxï¼Œåˆ™ä¿®æ”¹mxä¸idï¼‰ å¯¹äº $mx &lt;= i$ çš„æƒ…å†µï¼Œæ— æ³•å¯¹ P[i]åšæ›´å¤šçš„å‡è®¾ï¼Œåªèƒ½$P[i] = 1$ï¼Œç„¶åå†å»åŒ¹é…äº†ã€‚ç”±äºæ¯ä¸€ä¸ªä½ç½®æœ€å¤šåªä¼šè¢«æœ´ç´ çš„åŒ¹é…ä¸€æ¬¡ï¼Œæ‰€ä»¥ç®—æ³•å¤æ‚ç¨‹åº¦$O(n)$; ä»£ç 12345678910111213141516171819202122int manacher()&#123; int len = strlen(s); int maxr = 0, mid = 0; for(int i = 1; i &lt; len; ++i) &#123; if(i &lt; maxr) val[i] = min(val[(mid&lt;&lt;1) - i], maxr-i); else val[i] = 1; while(s[i-val[i]] == s[i+val[i]]) val[i]++; if(val[i] + i &gt; maxr) &#123; maxr = val[i] + i; mid = i; &#125; printf("%d ", val[i]); &#125; return (*max_element(val, val+len)) - 1;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å­—ç¬¦ä¸²</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è€å¸æœºæ ‘]]></title>
    <url>%2F2019%2F03%2F24%2FODT%2F</url>
    <content type="text"><![CDATA[è€å¸æœºæ ‘(ODTï¼ŒåˆåChtholly Treeï¼Œç‚æœµè‰æ ‘), ç”±ODTå¤§ä½¬æå‡ºã€‚ ç®€ä»‹æ¥æºï¼šCodeforces896Cå¯¹äºä¸€ä¸ªåºåˆ—ï¼Œéšæœºåœ°è¿›è¡Œä¸€ç³»åˆ—åŒ…å«æ¨å¹³ä¸€æ®µåŒºé—´åœ¨å†…çš„æ“ä½œï¼Œå¯ä»¥é‡‡ç”¨è¿™ç§æ•°æ®ç»“æ„ å…¶æ ¸å¿ƒæ€æƒ³ä¸ºï¼Œå°†æ¯ä¸€æ®µå€¼ç›¸ç­‰çš„å­åºåˆ—ç”¨ä¸€ä¸ªä¸‰å…ƒç»„$(l, r, val)$è¡¨ç¤ºï¼Œç”±äºâ€œæ¨å¹³ä¸€æ®µåŒºé—´â€æ“ä½œçš„å­˜åœ¨ä¸”æ“ä½œæ˜¯éšæœºçš„ï¼Œæ‰€ä»¥ä¸‰å…ƒç»„åºåˆ—çš„é•¿åº¦å°†è¶‹è¿‘äº$log n$ã€‚ å¯¹äºæ¯æ¬¡æ“ä½œ$[L, R]$ï¼Œå°†åŒ…å«å¾…Læˆ–Rçš„ä¸‰å…ƒç»„$(x, y, val)$åˆ†æˆä¸¤ä¸ªä¸‰å…ƒç»„$(x, L-1, val)$, $(L, y, val)$, ä½¿å¾—$L, R$å¤„äºä¸‰å…ƒç»„çš„å·¦è¾¹ç•Œï¼Œç„¶åå¯¹åŒºé—´å†…éƒ¨çš„ä¸‰å…ƒç»„è¿›è¡Œæš´åŠ›ç»´æŠ¤ã€‚ é¡ºå¸¦æä¸€å¥ï¼Œå¦‚æœä½¿ç”¨setç»´æŠ¤ä¸‰å…ƒç»„çš„è¯ï¼Œç”±äºsetå†…éƒ¨çš„å…ƒç´ ä¸€æ—¦æ’å…¥å°±ä¸å¯æ›´æ”¹ï¼Œæ‰€ä»¥æˆå‘˜å˜é‡åº”å½“ä½¿ç”¨mutableå…³é”®å­—å£°æ˜ã€‚ æ³¨æ„å¦‚æœå€¼çš„æ›´æ”¹ä½¿å¾—å…ƒç´ çš„ä¼˜å…ˆçº§å‘ç”Ÿäº†å˜åŒ–ï¼Œå°†å¯¼è‡´setå†…éƒ¨å…ƒç´ ä¸å†æœ‰åº ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const vector&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const set&lt;T&gt;&amp; v)&#123; for(auto i : v) os &lt;&lt; i &lt;&lt; " "; return os;&#125;template&lt;typename T&gt;T read()&#123; T sgn = 1, res = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sgn = -sgn; c = getchar(); &#125; while('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; res = res * 10 + c - '0'; c = getchar(); &#125; return res * sgn;&#125;class node&#123; public: mutable ll l, r, val; node(ll l = 0, ll r = 0, ll val = 0): l(l), r(r), val(val)&#123;&#125; bool operator &lt; (const node&amp; cmp) const &#123; if(l == cmp.l) return r &lt; cmp.r; return l &lt; cmp.l; &#125; &#125;;class heapnode&#123; public: ll len, val; heapnode(ll len = 0, ll val = 0): len(len), val(val)&#123;&#125; bool operator &lt; (const heapnode&amp; cmp) const &#123; if(val == cmp.val) return len &lt; cmp.len; return val &lt; cmp.val; &#125;&#125;;const ll MOD = 1e9 + 7;const int N = 1e5 + 233;ll dig[N], seed, n, m, op, vm, l, r, x, y;set&lt;node&gt; s;vector&lt;heapnode&gt; v;ll rnd()&#123; ll ret = seed; seed = (seed * 7 + 13) % MOD; return ret;&#125;void getData()&#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;seed, &amp;vm); for(int i = 1; i &lt;= n; ++i) dig[i] = (rnd() % vm) + 1;&#125;void getOp()&#123; op = (rnd() % 4) + 1; l = (rnd() % n) + 1; r = (rnd() % n) + 1; x = y = 0; if(l &gt; r) swap(l, r); if(op == 3) x = (rnd() % (r-l+1)) + 1; else x = (rnd() % vm) + 1; if(op == 4) y = (rnd() % vm) + 1; &#125;set&lt;node&gt;::iterator split(int pos)&#123; auto p = s.lower_bound(node(pos)); if(p != s.end() &amp;&amp; p-&gt;l == pos) return p; p--; if(pos &gt; p-&gt;r) return s.end(); ll l = p-&gt;l; ll r = p-&gt;r; ll v = p-&gt;val; s.erase(p); s.emplace(l, pos-1, v); return s.emplace(pos, r, v).first;&#125;ll fp(ll x, ll y, ll mod)&#123; ll res = 1; x %= mod; while(y) &#123; if(y&amp;1) res *= x; x *= x; x %= mod; res %= mod; y &gt;&gt;= 1; &#125; return res;&#125;// #define localint main()&#123;#ifdef local freopen("data.txt", "r", stdin); freopen("ans.txt", "w", stdout);#endif getData(); for(int i = 1; i &lt;= n; ++i) s.emplace(i, i, dig[i]); while(m--) &#123; getOp(); split(l); auto sr = split(r+1); auto sl = split(l); switch(op) &#123; case 1: &#123; for(; sl != sr; ++sl) sl-&gt;val += x; break; &#125; case 2: &#123; s.erase(sl, sr); s.emplace(l, r, x); break; &#125; case 3: &#123; vector&lt;heapnode&gt;().swap(v); bool ok = false; for(; sl != sr; ++sl) v.emplace_back(sl-&gt;r - sl-&gt;l + 1, sl-&gt;val); sort(v.begin(), v.end()); for(auto i: v) &#123; x -= i.len; if(x &lt;= 0) &#123; printf("%I64d\n", i.val); ok = true; break; &#125; &#125; assert(ok); break; &#125; case 4: &#123; ll res = 0; while(sl != sr) &#123; ll temp = (sl-&gt;r - sl-&gt;l + 1) * fp(sl-&gt;val, x, y); temp %= y; res += temp; res %= y; sl++; &#125; printf("%I64d\n", res); break; &#125; default: assert(false); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>åŒºé—´ç»´æŠ¤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
